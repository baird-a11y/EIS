# üñ•Ô∏è **3. GUI-PROGRAMMIERUNG**

[‚Üê Zur√ºck zu: Paradigmen](2.%20Paradigmen.md) | [Zur √úbersicht](0.%20Index.md) | [Weiter zu: Vektorgrafik ‚Üí](4.%20Vektorgrafik%20Prozedural.md)

---

# üéØ **LERNZIELE**
- Event-driven Programming verstehen
- Qt/PySide6 Framework beherrschen
- Signal-Slot System anwenden
- Widget-Hierarchie aufbauen
- Paint-Events und Mausinteraktion

---

# üîÑ **EVENT-DRIVEN PROGRAMMING** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

## **Grundprinzip: Event-Loop**

```python
def event_loop(app_queue, top_window):
    while True:
        msg = wait_message(app_queue)
        if msg.type == MOUSE_DOWN:
            top_window.mouse_down(msg.x, msg.y)
        elif msg.type == MOUSE_UP:
            top_window.mouse_up(msg.x, msg.y)
        elif msg.type == KEY_PRESS:
            top_window.key_press(msg.key)
        elif msg.type == REPAINT:
            top_window.repaint()
        # ... weitere Events
```

## **Warum Event-driven?** ‚≠ê‚≠ê

### **Alternative: Polling (schlecht)**
```python
# Schlecht: St√§ndiges Abfragen
while True:
    if mouse_clicked():
        handle_click()
    if key_pressed():
        handle_key()
    time.sleep(0.01)  # Verschwendet CPU!
```

### **Besser: Event-driven**
```python
# Gut: Reagiert nur bei Bedarf
def on_mouse_click(event):
    handle_click(event)
    
def on_key_press(event):
    handle_key(event)
    
app.run()  # Wartet auf Events
```

## **Vorteile von Event-driven:**
- **Effizienz**: CPU nur bei Bedarf aktiv
- **Responsivit√§t**: Sofortige Reaktion auf Benutzer
- **Modularit√§t**: Jeder Event hat eigenen Handler
- **Parallelit√§t**: GUI l√§uft parallel zu anderen Threads

---

# üèóÔ∏è **QT/PYSIDE6 FRAMEWORK** ‚≠ê‚≠ê‚≠ê

## **Widget-Hierarchie** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

```
QApplication
‚îî‚îÄ‚îÄ QMainWindow
    ‚îú‚îÄ‚îÄ QMenuBar
    ‚îÇ   ‚îú‚îÄ‚îÄ QMenu ("File")
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ QAction ("Open")
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ QAction ("Save")
    ‚îÇ   ‚îî‚îÄ‚îÄ QMenu ("Edit")
    ‚îú‚îÄ‚îÄ QToolBar
    ‚îÇ   ‚îú‚îÄ‚îÄ QAction ("New")
    ‚îÇ   ‚îî‚îÄ‚îÄ QAction ("Cut")
    ‚îú‚îÄ‚îÄ QWidget (Central Widget)
    ‚îÇ   ‚îî‚îÄ‚îÄ QVBoxLayout
    ‚îÇ       ‚îú‚îÄ‚îÄ QHBoxLayout (Toolbar)
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ QPushButton ("Rectangle")
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ QPushButton ("Circle")
    ‚îÇ       ‚îî‚îÄ‚îÄ CustomDrawingArea
    ‚îî‚îÄ‚îÄ QStatusBar
```

## **Grundstruktur einer Qt-Anwendung** ‚≠ê‚≠ê‚≠ê

```python
import sys
from PySide6.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout
from PySide6.QtCore import Qt
from PySide6.QtGui import QPainter, QColor

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("EiS - Vektorgrafik")
        self.setGeometry(100, 100, 800, 600)
        
        # Central Widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Layout
        layout = QVBoxLayout(central_widget)
        
        # Custom Drawing Area
        self.drawing_area = DrawingArea()
        layout.addWidget(self.drawing_area)
        
        # Menu und Toolbar
        self.create_menu_bar()
        self.create_toolbar()

class DrawingArea(QWidget):
    def __init__(self):
        super().__init__()
        self.setMinimumSize(400, 300)
        
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.fillRect(self.rect(), QColor(255, 255, 255))
        # Hier wird gezeichnet
        painter.end()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    app.exec()
```

---

# üéõÔ∏è **SIGNAL-SLOT SYSTEM** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

## **Grundprinzip: Lose Kopplung**

```python
# Signal-Slot Verbindung
button.clicked.connect(self.handle_button_click)
action.triggered.connect(self.save_file)
slider.valueChanged.connect(self.update_zoom)
```

## **Verschiedene Verbindungsarten** ‚≠ê‚≠ê

### **1. Methoden-Slot**
```python
def handle_click(self):
    print("Button clicked!")

button.clicked.connect(self.handle_click)
```

### **2. Lambda-Slot**
```python
button.clicked.connect(lambda: print("Button clicked!"))
```

### **3. Slot mit Parametern**
```python
def set_color(self, color):
    self.current_color = color

red_button.clicked.connect(lambda: self.set_color(QColor(255, 0, 0)))
green_button.clicked.connect(lambda: self.set_color(QColor(0, 255, 0)))
```

### **4. Ein Signal, mehrere Slots**
```python
# Ein Signal kann mehrere Slots haben
self.save_action.triggered.connect(self.save_file)
self.save_action.triggered.connect(self.update_status)
self.save_action.triggered.connect(self.mark_as_saved)
```

## **Eigene Signals definieren** ‚≠ê‚≠ê

```python
from PySide6.QtCore import Signal

class CustomWidget(QWidget):
    # Custom Signal definieren
    value_changed = Signal(int)
    shape_selected = Signal(str)
    
    def __init__(self):
        super().__init__()
        self.value = 0
    
    def set_value(self, new_value):
        if self.value != new_value:
            self.value = new_value
            self.value_changed.emit(new_value)  # Signal senden
    
    def select_shape(self, shape_type):
        self.shape_selected.emit(shape_type)

# Verwendung:
widget = CustomWidget()
widget.value_changed.connect(lambda v: print(f"Value changed to {v}"))
widget.shape_selected.connect(lambda s: print(f"Shape selected: {s}"))
```

---

# üé® **PAINT-EVENTS UND ZEICHNEN** ‚≠ê‚≠ê‚≠ê

## **QPainter Grundlagen** ‚≠ê‚≠ê‚≠ê

```python
class DrawingArea(QWidget):
    def __init__(self):
        super().__init__()
        self.shapes = []
        
    def paintEvent(self, event):
        """Wird automatisch aufgerufen wenn Widget neu gezeichnet werden muss"""
        painter = QPainter(self)
        
        # Hintergrund
        painter.fillRect(self.rect(), QColor(255, 255, 255))
        
        # Antialiasing f√ºr glatte Linien
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Shapes zeichnen
        for shape in self.shapes:
            shape.draw(painter)
        
        painter.end()  # Wichtig: Painter freigeben!
```

## **Wichtige QPainter Methoden** ‚≠ê‚≠ê

```python
def draw_examples(self, painter):
    # Pen (Linien) und Brush (F√ºllung) setzen
    pen = QPen(QColor(0, 0, 0), 2)  # Schwarz, 2px dick
    brush = QBrush(QColor(255, 0, 0))  # Rote F√ºllung
    painter.setPen(pen)
    painter.setBrush(brush)
    
    # Grundformen zeichnen
    painter.drawRect(10, 10, 100, 50)  # Rechteck
    painter.drawEllipse(120, 10, 80, 80)  # Kreis/Ellipse
    painter.drawLine(10, 100, 200, 100)  # Linie
    
    # Polygon (f√ºr Stern)
    from PySide6.QtGui import QPolygonF, QPointF
    points = [QPointF(250, 50), QPointF(270, 90), QPointF(310, 90), 
              QPointF(280, 110), QPointF(290, 150), QPointF(250, 130)]
    polygon = QPolygonF(points)
    painter.drawPolygon(polygon)
    
    # Text zeichnen
    painter.drawText(10, 200, "Hello Qt!")
```

## **Double Buffering Pattern** ‚≠ê‚≠ê

```python
class DrawingArea(QWidget):
    def __init__(self):
        super().__init__()
        self.buffer = QImage(800, 600, QImage.Format.Format_RGB32)
        self.buffer.fill(QColor(255, 255, 255))
        
    def paintEvent(self, event):
        # Vom Buffer zum Widget kopieren
        painter = QPainter(self)
        painter.drawImage(0, 0, self.buffer)
        
    def draw_on_buffer(self, x, y):
        # Auf Buffer zeichnen (persistent)
        painter = QPainter(self.buffer)
        painter.setPen(QPen(QColor(0, 0, 0), 3))
        painter.drawPoint(x, y)
        painter.end()
        
        self.update()  # paintEvent triggern
```

---

# üê≠ **MAUS-EVENTS** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

## **Grundlegende Maus-Events** ‚≠ê‚≠ê‚≠ê

```python
class InteractiveArea(QWidget):
    def __init__(self):
        super().__init__()
        self.drawing = False
        self.last_point = None
        self.current_shape = None
        
    def mousePressEvent(self, event):
        """Mausknopf gedr√ºckt"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.drawing = True
            self.last_point = event.pos()
            print(f"Mouse pressed at ({event.x()}, {event.y()})")
            
    def mouseMoveEvent(self, event):
        """Maus bewegt (mit oder ohne Knopf)"""
        if self.drawing and self.last_point:
            # Linie zeichnen
            painter = QPainter(self.buffer)
            painter.setPen(QPen(QColor(0, 0, 0), 2))
            painter.drawLine(self.last_point, event.pos())
            painter.end()
            
            self.last_point = event.pos()
            self.update()
            
    def mouseReleaseEvent(self, event):
        """Mausknopf losgelassen"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.drawing = False
            print("Mouse released")
            
    def wheelEvent(self, event):
        """Mausrad gedreht"""
        delta = event.angleDelta().y()
        if delta > 0:
            self.zoom_in()
        else:
            self.zoom_out()
```

## **Koordinaten-Systeme** ‚≠ê‚≠ê

```python
def mousePressEvent(self, event):
    # Widget-Koordinaten (Pixel)
    widget_x = event.x()
    widget_y = event.y()
    
    # Zu Welt-Koordinaten transformieren
    world_x, world_y = self.widget_to_world(widget_x, widget_y)
    
    # Hit-Testing
    clicked_shape = self.find_shape_at(world_x, world_y)
    if clicked_shape:
        clicked_shape.select()
        
def widget_to_world(self, widget_x, widget_y):
    # Ber√ºcksichtigt Zoom und Pan
    world_x = (widget_x / self.zoom) + self.pan_x
    world_y = (widget_y / self.zoom) + self.pan_y
    return world_x, world_y
```

---

# üîß **MEN√úS UND TOOLBARS** ‚≠ê‚≠ê

## **QAction - Zentrale Kommando-Abstraktion** ‚≠ê‚≠ê

```python
def create_menu_bar(self):
    menubar = self.menuBar()
    
    # File Menu
    file_menu = menubar.addMenu("&File")
    
    # Actions erstellen
    self.new_action = QAction("&New", self)
    self.new_action.setShortcut("Ctrl+N")
    self.new_action.setStatusTip("Create new document")
    self.new_action.triggered.connect(self.new_document)
    
    self.open_action = QAction("&Open...", self)
    self.open_action.setShortcut(QKeySequence.StandardKey.Open)
    self.open_action.triggered.connect(self.open_document)
    
    self.save_action = QAction("&Save", self)
    self.save_action.setShortcut(QKeySequence.StandardKey.Save)
    self.save_action.triggered.connect(self.save_document)
    
    # Actions zu Menu hinzuf√ºgen
    file_menu.addAction(self.new_action)
    file_menu.addAction(self.open_action)
    file_menu.addAction(self.save_action)
    file_menu.addSeparator()
    
    quit_action = QAction("&Quit", self)
    quit_action.setShortcut("Ctrl+Q")
    quit_action.triggered.connect(self.close)
    file_menu.addAction(quit_action)

def create_toolbar(self):
    toolbar = self.addToolBar("Main")
    
    # Gleiche Actions in Toolbar verwenden
    toolbar.addAction(self.new_action)
    toolbar.addAction(self.open_action)
    toolbar.addAction(self.save_action)
```

## **Warum QAction verwenden?** ‚≠ê‚≠ê

### **Vorteile:**
- **Einheitlichkeit**: Gleiches Verhalten in Menu und Toolbar
- **Keyboard Shortcuts**: Automatisch verf√ºgbar
- **Enable/Disable**: Zentral steuerbar
- **Icons und Tooltips**: Einmal definiert, √ºberall verwendet

```python
# Enable/Disable zentral steuern
def update_actions(self):
    has_document = self.current_document is not None
    self.save_action.setEnabled(has_document)
    self.close_action.setEnabled(has_document)
```

---

# üìÅ **DATEI-DIALOGE** ‚≠ê‚≠ê

## **QFileDialog verwenden** ‚≠ê‚≠ê

```python
def open_document(self):
    file_path, _ = QFileDialog.getOpenFileName(
        self,
        "Open Document",
        "",  # Startverzeichnis
        "All Files (*.*);;Text Files (*.txt);;Python Files (*.py)"
    )
    
    if file_path:
        try:
            with open(file_path, 'r') as file:
                content = file.read()
                self.text_edit.setPlainText(content)
                self.statusBar().showMessage(f"Opened: {file_path}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not open file: {str(e)}")

def save_document(self):
    file_path, _ = QFileDialog.getSaveFileName(
        self,
        "Save Document",
        "untitled.txt",  # Vorschlag
        "Text Files (*.txt);;All Files (*.*)"
    )
    
    if file_path:
        try:
            with open(file_path, 'w') as file:
                file.write(self.text_edit.toPlainText())
                self.statusBar().showMessage(f"Saved: {file_path}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not save file: {str(e)}")
```

## **QMessageBox f√ºr Benutzer-Feedback** ‚≠ê‚≠ê

```python
def close_document(self):
    if self.document_modified:
        reply = QMessageBox.question(
            self,
            "Save Changes?",
            "The document has been modified. Do you want to save changes?",
            QMessageBox.StandardButton.Save | 
            QMessageBox.StandardButton.Discard | 
            QMessageBox.StandardButton.Cancel,
            QMessageBox.StandardButton.Save  # Default
        )
        
        if reply == QMessageBox.StandardButton.Save:
            self.save_document()
        elif reply == QMessageBox.StandardButton.Cancel:
            return  # Abbrechen
        # Discard: Einfach weitermachen
    
    self.current_document = None
    self.update_actions()
```

---

# üéØ **KLAUSUR-TYPISCHE FRAGEN**

## **Theoretische Fragen** ‚≠ê‚≠ê‚≠ê

### **1. Warum ist Event-driven Programming besser als Polling?**
**Musterl√∂sung:**
- Effizienter: CPU nur bei Bedarf aktiv
- Responsiver: Sofortige Reaktion auf Events
- Modularer: Jeder Event hat eigenen Handler
- Skalierbar: Kann viele Events gleichzeitig handhaben

### **2. Erkl√§ren Sie das Signal-Slot System von Qt**
**Musterl√∂sung:**
- Lose Kopplung zwischen Sender und Empf√§nger
- Ein Signal kann mehrere Slots haben
- Slots k√∂nnen Lambda-Funktionen oder Methoden sein
- Erm√∂glicht flexible Event-Behandlung

### **3. Warum ist paintEvent() wichtig?**
**Musterl√∂sung:**
- Wird automatisch aufgerufen bei Repaint-Bedarf
- Erm√∂glicht Double Buffering
- Alle Zeichnungen m√ºssen hier stattfinden
- Wird von Qt-Event-Loop getriggert

## **Praktische Aufgaben** ‚≠ê‚≠ê‚≠ê

### **1. Implementieren Sie ein Paint-Widget**
```python
class PaintWidget(QWidget):
    def __init__(self):
        super().__init__()
        # Ihre Implementierung
        
    def paintEvent(self, event):
        # Zeichnen implementieren
        pass
        
    def mousePressEvent(self, event):
        # Maus-Interaktion implementieren
        pass
```

### **2. Erstellen Sie ein Men√º-System**
```python
def create_menu(self):
    # Menu mit Actions erstellen
    # Shortcuts hinzuf√ºgen
    # Signal-Slot Verbindungen
    pass
```

### **3. Implementieren Sie Zoom/Pan**
```python
def wheelEvent(self, event):
    # Zoom implementieren
    pass
    
def mouseMoveEvent(self, event):
    # Pan implementieren
    pass
```

---

# üîó **NAVIGATION**

- [‚Üê Zur√ºck zu: Paradigmen](2.%20Paradigmen.md)
- [Zur √úbersicht](0.%20Index.md)
- [Weiter zu: Vektorgrafik Prozedural ‚Üí](4.%20Vektorgrafik%20Prozedural.md)
- [Sprung zu: OOP ‚Üí](5.%20OOP.md)

---

# üìù **ZUSAMMENFASSUNG**

## **Wichtigste Punkte f√ºr die Klausur:**
1. **Event-Loop**: Wartet auf Events, dispatched sie an Handler
2. **Signal-Slot**: Lose Kopplung, ein Signal kann mehrere Slots haben
3. **paintEvent()**: Wird automatisch aufgerufen, alle Zeichnungen hier
4. **Widget-Hierarchie**: Parent-Child System f√ºr Layout
5. **QAction**: Einheitliche Kommandos f√ºr Menu und Toolbar

## **Typische Klausurfragen:**
- Event-driven vs. Polling erkl√§ren
- Signal-Slot Verbindungen erstellen
- paintEvent() implementieren
- Maus-Events behandeln
- Menu/Toolbar mit QAction erstellen

## **H√§ufige Fehler vermeiden:**
- `super().__init__()` nicht vergessen
- `painter.end()` nach QPainter verwenden
- `self.update()` nach √Ñnderungen aufrufen
- Event-Parameter richtig verwenden (`event.pos()` statt `event.x`, `event.y`)