# üåä **6. FUNKTIONALE PROGRAMMIERUNG**

[‚Üê Zur√ºck zu: OOP](eis_oop.md) | [Zur √úbersicht](eis_main_index.md) | [Weiter zu: Performance ‚Üí](7.%20Performance.md)

---

# üéØ **LERNZIELE**
- Datenfluss-Architektur verstehen
- Unver√§nderlichkeit (Immutability) anwenden
- Reine Funktionen schreiben
- SVG-Export implementieren
- Funktionale vs. OOP Trade-offs kennen

---

# üîÑ **DATENFLUSS-ARCHITEKTUR** ‚≠ê‚≠ê‚≠ê **(SEHR KLAUSURRELEVANT)**

## **Pipeline-Verarbeitung Konzept**

```python
# Daten flie√üen durch Transformationspipeline
rectangles = create_rectangles()
triangles = convert_to_triangles(rectangles)      # Shapes ‚Üí Triangles
subdivided = subdivide_triangles(triangles, 2)    # Triangles ‚Üí mehr Triangles  
deformed = sine_wave_deform_triangles(subdivided) # Triangles ‚Üí deformierte Triangles
svg_text = export_to_svg(deformed)                # Triangles ‚Üí SVG-String
```

## **Geometrie-Extraktion f√ºr Funktionale Operationen** ‚≠ê‚≠ê‚≠ê

### **Das Problem:**
OOP-Shapes kapseln ihre Geometrie ‚Üí schwer f√ºr funktionale Transformationen

### **L√∂sung: Hybrid-Interface**
```python
from abc import ABC, abstractmethod
from typing import List, Tuple

Point = Tuple[float, float]
Triangle = Tuple[Point, Point, Point]

class VectorShape(ABC):
    @abstractmethod
    def draw(self, painter):         # OO-Interface f√ºr GUI
        pass
    
    @abstractmethod  
    def describe_shape(self) -> List[Triangle]:  # Funktionales Interface
        """Extrahiert Geometrie als Triangles f√ºr funktionale Operationen"""
        pass
```

### **Implementierung f√ºr verschiedene Shapes:**

```python
class Rectangle(VectorShape):
    def describe_shape(self) -> List[Triangle]:
        """Rechteck als 2 Dreiecke darstellen"""
        p1 = (self.x, self.y)                           # Oben Links
        p2 = (self.x + self.width, self.y)              # Oben Rechts  
        p3 = (self.x + self.width, self.y + self.height) # Unten Rechts
        p4 = (self.x, self.y + self.height)             # Unten Links
        
        triangle1 = (p1, p2, p3)  # Diagonale p1 ‚Üí p3
        triangle2 = (p1, p3, p4)  # Diagonale p1 ‚Üí p3
        return [triangle1, triangle2]

class Circle(VectorShape):
    def describe_shape(self) -> List[Triangle]:
        """Kreis als n Dreiecke (Pizza-St√ºcke)"""
        center_x = self.x + self.width/2
        center_y = self.y + self.height/2
        center_point = (center_x, center_y)
        radius = min(self.width, self.height)/2
        
        num_triangles = 32  # Aufl√∂sung
        triangles = []
        
        for i in range(num_triangles):
            angle1 = i * (2 * math.pi / num_triangles)
            angle2 = (i + 1) * (2 * math.pi / num_triangles)
            
            x1 = center_x + radius * math.cos(angle1)
            y1 = center_y + radius * math.sin(angle1)
            x2 = center_x + radius * math.cos(angle2)
            y2 = center_y + radius * math.sin(angle2)
            
            triangle = (center_point, (x1, y1), (x2, y2))
            triangles.append(triangle)
        
        return triangles

class Star(VectorShape):
    def describe_shape(self) -> List[Triangle]:
        """Stern als Dreiecke vom Zentrum zu den Kanten"""
        center_x = self.x + self.outer_radius
        center_y = self.y + self.outer_radius
        center_point = (center_x, center_y)
        
        # Stern-Punkte berechnen
        star_points = []
        for i in range(self.points * 2):
            angle = i * math.pi / self.points - math.pi/2
            radius = self.outer_radius if i % 2 == 0 else self.inner_radius
            
            x = center_x + radius * math.cos(angle)
            y = center_y + radius * math.sin(angle)
            star_points.append((x, y))
        
        # Dreiecke vom Zentrum zu benachbarten Stern-Punkten
        triangles = []
        for i in range(len(star_points)):
            next_i = (i + 1) % len(star_points)
            triangle = (center_point, star_points[i], star_points[next_i])
            triangles.append(triangle)
        
        return triangles
```

---

# üîß **FUNKTIONALE OPERATOREN** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

## **Triangle Subdivision** ‚≠ê‚≠ê‚≠ê

```python
def subdivide_triangle(triangle: Triangle) -> List[Triangle]:
    """
    Teilt 1 Dreieck in 4 kleinere Dreiecke
    Algorithmus: Mittelpunkte der Kanten verbinden
    """
    p1, p2, p3 = triangle
    
    # Mittelpunkte der Kanten berechnen
    m12 = ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)  # Mitte P1-P2
    m23 = ((p2[0] + p3[0]) / 2, (p2[1] + p3[1]) / 2)  # Mitte P2-P3
    m31 = ((p3[0] + p1[0]) / 2, (p3[1] + p1[1]) / 2)  # Mitte P3-P1
    
    # 4 neue Dreiecke erstellen
    t1 = (p1, m12, m31)      # Ecke bei P1
    t2 = (p2, m23, m12)      # Ecke bei P2  
    t3 = (p3, m31, m23)      # Ecke bei P3
    t4 = (m12, m23, m31)     # Mittleres Dreieck
    
    return [t1, t2, t3, t4]

def subdivide_triangles(triangles: List[Triangle], n_times: int = 1) -> List[Triangle]:
    """n-fache Subdivision aller Dreiecke"""
    result = triangles
    for _ in range(n_times):
        new_triangles = []
        for triangle in result:
            new_triangles.extend(subdivide_triangle(triangle))
        result = new_triangles
    return result
```

## **Sine-Wave Deformation** ‚≠ê‚≠ê‚≠ê

```python
def sine_wave_deform_point(point: Point, amplitude: float = 50.0, 
                          wavelength: float = 200.0, phase: float = 0.0) -> Point:
    """
    Deformiert einen Punkt entlang einer Sinuskurve
    
    Args:
        point: (x, y) Koordinaten
        amplitude: H√∂he der Welle
        wavelength: Wellenl√§nge
        phase: Phasenverschiebung
    """
    x, y = point
    y_offset = amplitude * math.sin(2 * math.pi * x / wavelength + phase)
    return (x, y + y_offset)

def sine_wave_deform_triangles(triangles: List[Triangle], 
                              amplitude: float = 50.0, 
                              wavelength: float = 200.0, 
                              phase: float = 0.0) -> List[Triangle]:
    """Wendet Sine-Wave Deformation auf alle Dreiecke an"""
    deformed_triangles = []
    
    for triangle in triangles:
        p1, p2, p3 = triangle
        
        # Jeden Punkt des Dreiecks transformieren
        new_p1 = sine_wave_deform_point(p1, amplitude, wavelength, phase)
        new_p2 = sine_wave_deform_point(p2, amplitude, wavelength, phase)
        new_p3 = sine_wave_deform_point(p3, amplitude, wavelength, phase)
        
        deformed_triangle = (new_p1, new_p2, new_p3)
        deformed_triangles.append(deformed_triangle)
    
    return deformed_triangles
```

## **Higher-Order Functions** ‚≠ê‚≠ê

```python
def apply_to_all_triangles(triangles: List[Triangle], 
                          transform_func) -> List[Triangle]:
    """Higher-Order Function: Nimmt Funktion als Parameter"""
    return [transform_func(triangle) for triangle in triangles]

def map_triangles(triangles: List[Triangle], 
                 point_transform_func) -> List[Triangle]:
    """Wendet Punkt-Transformation auf alle Dreiecks-Punkte an"""
    def transform_triangle(triangle: Triangle) -> Triangle:
        p1, p2, p3 = triangle
        return (point_transform_func(p1), 
                point_transform_func(p2), 
                point_transform_func(p3))
    
    return [transform_triangle(t) for t in triangles]

# Verwendung:
deformed = apply_to_all_triangles(
    triangles, 
    lambda t: sine_wave_deform_triangle(t, amplitude=30)
)

scaled = map_triangles(
    triangles,
    lambda p: (p[0] * 2, p[1] * 2)  # 2x Skalierung
)
```

---

# üìÑ **SVG-EXPORT** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

## **SVG-Format Grundlagen** ‚≠ê‚≠ê

```xml
<!-- SVG-Grundstruktur -->
<svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
  <!-- Dreieck als Polygon -->
  <polygon points="100,100 200,100 150,50" 
           fill="lightblue" 
           stroke="black" 
           stroke-width="2" />
  
  <!-- Mehrere Dreiecke -->
  <polygon points="300,100 400,100 350,50" fill="red" />
  <polygon points="500,100 600,100 550,50" fill="green" />
</svg>
```

## **Funktionale SVG-Serialisierung** ‚≠ê‚≠ê‚≠ê

```python
def export_triangles_as_svg(triangles: List[Triangle], 
                           filename: str, 
                           width: int = 800, 
                           height: int = 600,
                           colors: List[str] = None) -> None:
    """
    Exportiert Dreiecke als SVG-Datei
    Reine Funktion: Keine Seiteneffekte au√üer Datei schreiben
    """
    if colors is None:
        colors = ["lightblue", "lightgreen", "lightcoral", "lightyellow"]
    
    with open(filename, "w") as file:
        # SVG Header
        file.write(f'<svg width="{width}" height="{height}" '
                  f'xmlns="http://www.w3.org/2000/svg">\n')
        
        # Jedes Dreieck als Polygon
        for i, triangle in enumerate(triangles):
            p1, p2, p3 = triangle
            
            # Points-String f√ºr SVG
            points = f"{p1[0]},{p1[1]} {p2[0]},{p2[1]} {p3[0]},{p3[1]}"
            
            # Farbe basierend auf Index
            color = colors[i % len(colors)]
            
            # SVG-Polygon Element
            file.write(f'  <polygon points="{points}" '
                      f'fill="{color}" '
                      f'stroke="black" '
                      f'stroke-width="0.5" />\n')
        
        # SVG Footer
        file.write('</svg>\n')

def triangles_to_svg_string(triangles: List[Triangle],
                           width: int = 800,
                           height: int = 600) -> str:
    """
    Konvertiert Dreiecke zu SVG-String
    Reine Funktion: Keine Seiteneffekte
    """
    svg_lines = []
    svg_lines.append(f'<svg width="{width}" height="{height}" '
                    f'xmlns="http://www.w3.org/2000/svg">')
    
    for triangle in triangles:
        p1, p2, p3 = triangle
        points = f"{p1[0]},{p1[1]} {p2[0]},{p2[1]} {p3[0]},{p3[1]}"
        svg_lines.append(f'  <polygon points="{points}" '
                        f'fill="lightblue" stroke="black" />')
    
    svg_lines.append('</svg>')
    return '\n'.join(svg_lines)
```

---

# üîÑ **FUNKTIONALE PIPELINE** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

## **Komplette Verarbeitungskette** ‚≠ê‚≠ê‚≠ê

```python
def create_deformed_svg(shapes: List[VectorShape], 
                       filename: str,
                       subdivision_levels: int = 2,
                       wave_amplitude: float = 30.0,
                       wave_wavelength: float = 300.0) -> None:
    """
    Komplette funktionale Verarbeitungspipeline
    
    Pipeline: Shapes ‚Üí Triangles ‚Üí Subdivide ‚Üí Deform ‚Üí SVG
    """
    
    # 1. Shapes ‚Üí Triangles (Geometrie extrahieren)
    print("Step 1: Extracting geometry...")
    all_triangles = []
    for shape in shapes:
        triangles = shape.describe_shape()
        all_triangles.extend(triangles)
    print(f"Extracted {len(all_triangles)} triangles from {len(shapes)} shapes")
    
    # 2. Subdivision f√ºr mehr Details
    print(f"Step 2: Subdividing {subdivision_levels} times...")
    fine_triangles = subdivide_triangles(all_triangles, subdivision_levels)
    print(f"After subdivision: {len(fine_triangles)} triangles")
    
    # 3. Sine-Wave Deformation
    print("Step 3: Applying sine wave deformation...")
    deformed_triangles = sine_wave_deform_triangles(
        fine_triangles, 
        amplitude=wave_amplitude, 
        wavelength=wave_wavelength, 
        phase=0
    )
    print(f"Deformed {len(deformed_triangles)} triangles")
    
    # 4. Export als SVG
    print("Step 4: Exporting to SVG...")
    export_triangles_as_svg(deformed_triangles, filename)
    print(f"SVG exported to {filename}")
    
    # Pipeline-Statistik
    print(f"\nPipeline Summary:")
    print(f"  {len(shapes)} Shapes ‚Üí {len(all_triangles)} ‚Üí "
          f"{len(fine_triangles)} ‚Üí {len(deformed_triangles)} Triangles ‚Üí {filename}")

# Verwendung:
shapes = [
    Rectangle(0, 0, 100, 50),
    Circle(50, 50, 30),
    Star(100, 100, 40, 20, 5)
]

create_deformed_svg(shapes, "output.svg", subdivision_levels=3)
```

## **Funktionale Komposition** ‚≠ê‚≠ê

```python
def compose_transformations(*functions):
    """Komponiert mehrere Funktionen zu einer Pipeline"""
    def composed_function(data):
        result = data
        for func in functions:
            result = func(result)
        return result
    return composed_function

# Pipeline als Komposition
triangle_pipeline = compose_transformations(
    lambda triangles: subdivide_triangles(triangles, 2),
    lambda triangles: sine_wave_deform_triangles(triangles, amplitude=25),
    lambda triangles: export_triangles_as_svg(triangles, "output.svg")
)

# Verwendung:
initial_triangles = []
for shape in shapes:
    initial_triangles.extend(shape.describe_shape())

triangle_pipeline(initial_triangles)
```

---

# üßä **UNVER√ÑNDERLICHKEIT (IMMUTABILITY)** ‚≠ê‚≠ê‚≠ê

## **Prinzip: Original bleibt unver√§ndert** ‚≠ê‚≠ê‚≠ê

```python
# ‚úÖ FUNKTIONAL: Keine Seiteneffekte
def add_triangle(triangles: List[Triangle], new_triangle: Triangle) -> List[Triangle]:
    """Gibt neue Liste zur√ºck, Original bleibt unver√§ndert"""
    return triangles + [new_triangle]  # Neue Liste

def scale_triangle(triangle: Triangle, factor: float) -> Triangle:
    """Gibt neues Dreieck zur√ºck, Original bleibt unver√§ndert"""
    p1, p2, p3 = triangle
    return (
        (p1[0] * factor, p1[1] * factor),
        (p2[0] * factor, p2[1] * factor),
        (p3[0] * factor, p3[1] * factor)
    )

# ‚ùå IMPERATIV: Seiteneffekte
def add_triangle_bad(triangles: List[Triangle], new_triangle: Triangle) -> None:
    """Ver√§ndert Original-Liste!"""
    triangles.append(new_triangle)  # Seiteneffekt!

def scale_triangle_bad(triangle: Triangle, factor: float) -> None:
    """Unm√∂glich - Tupel sind unver√§nderlich"""
    # triangle[0] = (triangle[0][0] * factor, triangle[0][1] * factor)  # Fehler!
```

## **Vorteile von Immutability** ‚≠ê‚≠ê

### **1. Thread-Sicherheit**
```python
# Unver√§nderliche Daten k√∂nnen sicher zwischen Threads geteilt werden
import threading

def worker_thread(triangles: List[Triangle]):
    """Kann triangles sicher verwenden ohne Locks"""
    deformed = sine_wave_deform_triangles(triangles, amplitude=20)
    # Original triangles bleiben unver√§ndert
    return deformed

# Sicher parallel ausf√ºhren
thread1 = threading.Thread(target=worker_thread, args=(triangles,))
thread2 = threading.Thread(target=worker_thread, args=(triangles,))
```

### **2. Einfaches Debugging**
```python
# Unver√§nderliche Daten: Zustand √§ndert sich nicht unerwartet
def debug_pipeline(triangles: List[Triangle]) -> List[Triangle]:
    print(f"Input: {len(triangles)} triangles")
    
    subdivided = subdivide_triangles(triangles, 1)
    print(f"After subdivision: {len(subdivided)} triangles")
    print(f"Original still: {len(triangles)} triangles")  # Unver√§ndert!
    
    deformed = sine_wave_deform_triangles(subdivided, amplitude=10)
    print(f"After deformation: {len(deformed)} triangles")
    print(f"Subdivided still: {len(subdivided)} triangles")  # Unver√§ndert!
    
    return deformed
```

### **3. Undo/Redo System**
```python
class FunctionalEditor:
    def __init__(self):
        self.history = []
        self.current_state = []
    
    def apply_transformation(self, transform_func):
        """Wendet Transformation an und speichert History"""
        new_state = transform_func(self.current_state)
        self.history.append(self.current_state)  # Alte Zust√§nde bleiben erhalten
        self.current_state = new_state
    
    def undo(self):
        """Undo durch Zur√ºckgehen in History"""
        if self.history:
            self.current_state = self.history.pop()
    
    def redo(self):
        """Redo durch erneute Anwendung der Transformation"""
        # M√∂glich weil alle Transformationen reine Funktionen sind
        pass
```

---

# üîÑ **HYBRID OO/FUNKTIONAL INTEGRATION** ‚≠ê‚≠ê‚≠ê

## **Functional Core, Imperative Shell** ‚≠ê‚≠ê‚≠ê

```python
class VectorGraphicsWindow(QMainWindow):
    """OO f√ºr GUI, Funktional f√ºr Verarbeitung"""
    
    def __init__(self):
        super().__init__()
        self.shapes = []  # OO: Ver√§nderlicher Zustand
        self.setup_ui()
    
    def export_svg(self):
        """GUI-Integration: OO f√ºr Events, Funktional f√ºr Verarbeitung"""
        file_path, _ = QFileDialog.getSaveFileName(
            self, "SVG Export", "output.svg", "SVG Files (*.svg)"
        )
        
        if file_path:
            # Funktionale Pipeline aufrufen
            create_deformed_svg(self.shapes, file_path)
            QMessageBox.information(self, "Success", f"SVG exported: {file_path}")
    
    def apply_transformations(self):
        """Demo: Funktionale Operationen √ºber GUI anwenden"""
        # OO: Shapes aus GUI extrahieren
        all_triangles = []
        for shape in self.shapes:
            all_triangles.extend(shape.describe_shape())
        
        # Funktional: Transformationen anwenden
        subdivided = subdivide_triangles(all_triangles, 1)
        deformed = sine_wave_deform_triangles(subdivided, amplitude=20)
        
        # OO: Ergebnis in GUI visualisieren
        # (Hier w√ºrde man eine spezielle TriangleCollection-Shape erstellen)
        self.visualize_triangles(deformed)
    
    def visualize_triangles(self, triangles: List[Triangle]):
        """Zeigt Dreiecke in GUI an"""
        # Erstelle tempor√§re Shape-Objekte f√ºr Visualisierung
        triangle_shapes = []
        for triangle in triangles:
            # Konvertiere Triangle zu Shape-Objekt
            shape = TriangleShape(triangle)
            triangle_shapes.append(shape)
        
        # F√ºge zu GUI hinzu
        self.shapes.extend(triangle_shapes)
        self.update()

class TriangleShape(VectorShape):
    """Wrapper um Triangle f√ºr GUI-Integration"""
    def __init__(self, triangle: Triangle):
        self.triangle = triangle
        p1, p2, p3 = triangle
        
        # Bounding Box berechnen
        min_x = min(p1[0], p2[0], p3[0])
        max_x = max(p1[0], p2[0], p3[0])
        min_y = min(p1[1], p2[1], p3[1])
        max_y = max(p1[1], p2[1], p3[1])
        
        super().__init__(min_x, min_y, max_x - min_x, max_y - min_y)
    
    def draw(self, painter, viewport, pixel_size):
        """Zeichnet das Dreieck"""
        p1, p2, p3 = self.triangle
        
        # Zu Pixelkoordinaten transformieren
        points = []
        for px, py in [p1, p2, p3]:
            pixel_x, pixel_y = world_to_pixel(px, py, viewport, pixel_size)
            points.append(QPointF(pixel_x, pixel_y))
        
        # Polygon zeichnen
        polygon = QPolygonF(points)
        painter.setBrush(QBrush(QColor(200, 200, 255, 100)))
        painter.setPen(QPen(QColor(0, 0, 0), 1))
        painter.drawPolygon(polygon)
    
    def describe_shape(self) -> List[Triangle]:
        """Gibt sich selbst als Triangle zur√ºck"""
        return [self.triangle]
```

---

# üéØ **KLAUSUR-TYPISCHE FRAGEN**

## **Theoretische Fragen** ‚≠ê‚≠ê‚≠ê

### **1. Erkl√§ren Sie das Konzept der Datenfluss-Architektur**
**Musterl√∂sung:**
- Daten flie√üen durch Pipeline von Transformationsfunktionen
- Jede Stufe nimmt Input, transformiert ihn, gibt Output weiter
- Keine Seiteneffekte, nur Datentransformation
- Beispiel: Shapes ‚Üí Triangles ‚Üí Subdivide ‚Üí Deform ‚Üí SVG

### **2. Warum ist Unver√§nderlichkeit wichtig?**
**Musterl√∂sung:**
- Thread-Sicherheit: Keine Race Conditions
- Einfaches Debugging: Zustand √§ndert sich nicht unerwartet
- Undo/Redo: Alte Zust√§nde bleiben erhalten
- Caching: Unver√§nderliche Objekte sind cachebar

### **3. Was sind reine Funktionen?**
**Musterl√∂sung:**
- Keine Seiteneffekte (√§ndern keine globalen Variablen)
- Deterministische Ausgabe (gleiche Input ‚Üí gleiche Output)
- Referentielle Transparenz (Aufruf kann durch Ergebnis ersetzt werden)
- Beispiel: Mathematische Funktionen

## **Praktische Aufgaben** ‚≠ê‚≠ê‚≠ê

### **1. Implementieren Sie Triangle Subdivision**
```python
def subdivide_triangle(triangle: Triangle) -> List[Triangle]:
    """Teilt Dreieck in 4 kleinere Dreiecke"""
    # Ihre Implementierung hier
    pass
```

### **2. Implementieren Sie SVG-Export**
```python
def export_triangles_as_svg(triangles: List[Triangle], filename: str):
    """Exportiert Dreiecke als SVG-Datei"""
    # Ihre Implementierung hier
    pass
```

### **3. Implementieren Sie Higher-Order Function**
```python
def map_triangles(triangles: List[Triangle], transform_func) -> List[Triangle]:
    """Wendet Transformation auf alle Dreiecke an"""
    # Ihre Implementierung hier
    pass
```

---

# üîó **NAVIGATION**

- [‚Üê Zur√ºck zu: OOP](eis_oop.md)
- [Zur √úbersicht](eis_main_index.md)  
- [Weiter zu: Performance ‚Üí](7.%20Performance.md)
- [Sprung zu: Paradigmen ‚Üí](eis_paradigmen.md)

---

# üìù **ZUSAMMENFASSUNG**

## **Wichtigste Punkte f√ºr die Klausur:**
1. **Datenfluss-Pipeline**: Shapes ‚Üí Triangles ‚Üí Transform ‚Üí Export
2. **Unver√§nderlichkeit**: Original bleibt unver√§ndert, neue Objekte zur√ºckgeben
3. **Reine Funktionen**: Keine Seiteneffekte, deterministische Ausgabe
4. **SVG-Export**: Triangle zu XML-Polygon konvertieren
5. **Hybrid-Ansatz**: OO f√ºr GUI, Funktional f√ºr Verarbeitung

## **Typische Klausurfragen:**
- Triangle Subdivision implementieren
- SVG-Export-Funktion schreiben
- Unver√§nderlichkeit vs. Seiteneffekte erkl√§ren
- Funktionale Pipeline aufbauen
- Higher-Order Functions verwenden

## **Wichtige Formeln:**
```python
# Mittelpunkt zweier Punkte
midpoint = ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)

# Sine-Wave Deformation
y_offset = amplitude * sin(2 * œÄ * x / wavelength + phase)

# SVG Polygon Format
f'<polygon points="{x1},{y1} {x2},{y2} {x3},{y3}" fill="color" />'
```