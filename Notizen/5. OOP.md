# üé≠ **5. OBJEKTORIENTIERTE PROGRAMMIERUNG**

[‚Üê Zur√ºck zu: Vektorgrafik Prozedural](4.%20Vektorgrafik%20Prozedural.md) | [Zur √úbersicht](0.%20Index.md) | [Weiter zu: Funktional ‚Üí](6.%20Funktional.md)

---

# üéØ **LERNZIELE**
- Abstrakte Klassen und Vererbung verstehen
- Polymorphismus praktisch anwenden
- SOLID Principles beherrschen
- Handle-System f√ºr Interaktion
- OOP vs. Prozedural Trade-offs kennen

---

# üèõÔ∏è **ABSTRAKTE KLASSEN** ‚≠ê‚≠ê‚≠ê **(SEHR KLAUSURRELEVANT)**

## **Grundprinzip: Gemeinsame Schnittstelle**

```python
from abc import ABC, abstractmethod
from typing import List, Tuple

class VectorShape(ABC):
    """Abstrakte Basisklasse f√ºr alle geometrischen Primitive"""
    
    def __init__(self, x: float, y: float, width: float, height: float):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.fill_color = QColor(100, 100, 255)
        self.border_color = QColor(0, 0, 0)
        self.border_width = 1.0
        self.selected = False
    
    @abstractmethod
    def draw(self, painter: QPainter, viewport: dict, pixel_size: tuple) -> None:
        """Zeichnet das Shape - muss in Unterklassen implementiert werden"""
        pass
    
    @abstractmethod
    def is_hit(self, world_x: float, world_y: float) -> bool:
        """Pr√ºft ob Punkt das Shape trifft"""
        pass
    
    @abstractmethod
    def get_bounding_box(self) -> dict:
        """Gibt Bounding Box zur√ºck"""
        pass
    
    @abstractmethod
    def get_num_handles(self) -> int:
        """Anzahl der Transformations-Handles"""
        pass
    
    @abstractmethod
    def get_handle(self, index: int) -> Tuple[float, float]:
        """Position des Handle mit gegebenem Index"""
        pass
    
    @abstractmethod
    def move_handle(self, index: int, world_x: float, world_y: float) -> None:
        """Verschiebt Handle auf neue Position"""
        pass
```

## **Warum abstrakte Klassen?** ‚≠ê‚≠ê‚≠ê

### **Vorteile:**
1. **Gemeinsame Schnittstelle**: Alle Shapes haben gleiche Methoden
2. **Polymorphismus**: Verschiedene Shapes einheitlich behandeln
3. **Code-Wiederverwendung**: Gemeinsame Attribute in Basisklasse
4. **Compile-Time-Sicherheit**: Vergessene Methoden werden erkannt

### **Beispiel: Vergessene Methode**
```python
class BadRectangle(VectorShape):  # ‚ùå Fehler!
    def draw(self, painter, viewport, pixel_size):
        pass
    # is_hit() fehlt! ‚Üí Python wirft TypeError
```

---

# üé® **KONKRETE IMPLEMENTIERUNGEN** ‚≠ê‚≠ê‚≠ê

## **Rectangle-Klasse** ‚≠ê‚≠ê‚≠ê

```python
class Rectangle(VectorShape):
    def draw(self, painter: QPainter, viewport: dict, pixel_size: tuple) -> None:
        # Koordinaten transformieren
        pixel_x, pixel_y = world_to_pixel(self.x, self.y, viewport, pixel_size)
        pixel_width = world_to_pixel_size(self.width, viewport, pixel_size, 'width')
        pixel_height = world_to_pixel_size(self.height, viewport, pixel_size, 'height')
        
        # Zeichnen
        painter.setBrush(QBrush(self.fill_color))
        painter.setPen(QPen(self.border_color, self.border_width))
        painter.drawRect(pixel_x, pixel_y, pixel_width, pixel_height)
    
    def is_hit(self, world_x: float, world_y: float) -> bool:
        """Bounding Box Test f√ºr Rechteck"""
        return (self.x <= world_x <= self.x + self.width and 
                self.y <= world_y <= self.y + self.height)
    
    def get_bounding_box(self) -> dict:
        return {
            'left': self.x,
            'right': self.x + self.width,
            'top': self.y + self.height,
            'bottom': self.y
        }
    
    def get_num_handles(self) -> int:
        return 4  # 4 Ecken
    
    def get_handle(self, index: int) -> Tuple[float, float]:
        """Handle-Positionen: 0=links oben, 1=rechts oben, 2=rechts unten, 3=links unten"""
        if index == 0:    # links oben
            return (self.x, self.y + self.height)
        elif index == 1:  # rechts oben
            return (self.x + self.width, self.y + self.height)
        elif index == 2:  # rechts unten
            return (self.x + self.width, self.y)
        elif index == 3:  # links unten
            return (self.x, self.y)
        else:
            raise IndexError(f"Handle index {index} out of range")
    
    def move_handle(self, index: int, world_x: float, world_y: float) -> None:
        """Verschiebt Handle und passt Rechteck an"""
        if index == 0:    # links oben
            new_width = self.x + self.width - world_x
            new_height = world_y - self.y
            self.x = world_x
            self.width = new_width
            self.height = new_height
        elif index == 1:  # rechts oben
            self.width = world_x - self.x
            self.height = world_y - self.y
        elif index == 2:  # rechts unten
            self.width = world_x - self.x
            new_height = self.y + self.height - world_y
            self.y = world_y
            self.height = new_height
        elif index == 3:  # links unten
            new_width = self.x + self.width - world_x
            new_height = self.y + self.height - world_y
            self.x = world_x
            self.y = world_y
            self.width = new_width
            self.height = new_height
```

## **Circle-Klasse** ‚≠ê‚≠ê

```python
class Circle(VectorShape):
    def __init__(self, x: float, y: float, radius: float):
        super().__init__(x, y, radius*2, radius*2)  # Bounding Box
        self.radius = radius
        self.fill_color = QColor(255, 100, 100)
    
    def draw(self, painter: QPainter, viewport: dict, pixel_size: tuple) -> None:
        # Kreismittelpunkt
        center_x = self.x + self.radius
        center_y = self.y + self.radius
        
        pixel_x, pixel_y = world_to_pixel(center_x, center_y, viewport, pixel_size)
        pixel_radius = world_to_pixel_size(self.radius, viewport, pixel_size, 'width')
        
        # Zeichnen (drawEllipse erwartet top-left corner)
        painter.setBrush(QBrush(self.fill_color))
        painter.setPen(QPen(self.border_color, self.border_width))
        painter.drawEllipse(pixel_x - pixel_radius, pixel_y - pixel_radius, 
                          2 * pixel_radius, 2 * pixel_radius)
    
    def is_hit(self, world_x: float, world_y: float) -> bool:
        """Pixelgenauer Kreis-Hit-Test"""
        center_x = self.x + self.radius
        center_y = self.y + self.radius
        
        dx = world_x - center_x
        dy = world_y - center_y
        distance = math.sqrt(dx*dx + dy*dy)
        return distance <= self.radius
    
    def get_bounding_box(self) -> dict:
        return {
            'left': self.x,
            'right': self.x + 2*self.radius,
            'top': self.y + 2*self.radius,
            'bottom': self.y
        }
    
    def get_num_handles(self) -> int:
        return 4  # 4 Kardinalrichtungen
    
    def get_handle(self, index: int) -> Tuple[float, float]:
        center_x = self.x + self.radius
        center_y = self.y + self.radius
        
        if index == 0:    # oben
            return (center_x, center_y + self.radius)
        elif index == 1:  # rechts
            return (center_x + self.radius, center_y)
        elif index == 2:  # unten
            return (center_x, center_y - self.radius)
        elif index == 3:  # links
            return (center_x - self.radius, center_y)
        else:
            raise IndexError(f"Handle index {index} out of range")
    
    def move_handle(self, index: int, world_x: float, world_y: float) -> None:
        center_x = self.x + self.radius
        center_y = self.y + self.radius
        
        if index == 0:    # oben
            self.radius = abs(world_y - center_y)
        elif index == 1:  # rechts
            self.radius = abs(world_x - center_x)
        elif index == 2:  # unten
            self.radius = abs(world_y - center_y)
        elif index == 3:  # links
            self.radius = abs(world_x - center_x)
        
        # Position anpassen (Kreis bleibt zentriert)
        self.x = center_x - self.radius
        self.y = center_y - self.radius
        self.width = self.height = 2 * self.radius
```

## **Star-Klasse** ‚≠ê‚≠ê

```python
class Star(VectorShape):
    def __init__(self, x: float, y: float, outer_radius: float, inner_radius: float, points: int = 5):
        super().__init__(x, y, outer_radius*2, outer_radius*2)
        self.outer_radius = outer_radius
        self.inner_radius = inner_radius
        self.points = points
        self.fill_color = QColor(255, 255, 100)
    
    def draw(self, painter: QPainter, viewport: dict, pixel_size: tuple) -> None:
        # Stern-Punkte berechnen
        center_x = self.x + self.outer_radius
        center_y = self.y + self.outer_radius
        
        vertices = []
        for i in range(self.points * 2):
            angle = i * math.pi / self.points - math.pi/2
            radius = self.outer_radius if i % 2 == 0 else self.inner_radius
            
            world_x = center_x + radius * math.cos(angle)
            world_y = center_y + radius * math.sin(angle)
            
            pixel_x, pixel_y = world_to_pixel(world_x, world_y, viewport, pixel_size)
            vertices.append(QPointF(pixel_x, pixel_y))
        
        # Polygon zeichnen
        polygon = QPolygonF(vertices)
        painter.setBrush(QBrush(self.fill_color))
        painter.setPen(QPen(self.border_color, self.border_width))
        painter.drawPolygon(polygon)
    
    def is_hit(self, world_x: float, world_y: float) -> bool:
        """Bounding Box Test f√ºr Stern"""
        return (self.x <= world_x <= self.x + 2*self.outer_radius and
                self.y <= world_y <= self.y + 2*self.outer_radius)
    
    def get_bounding_box(self) -> dict:
        return {
            'left': self.x,
            'right': self.x + 2*self.outer_radius,
            'top': self.y + 2*self.outer_radius,
            'bottom': self.y
        }
    
    def get_num_handles(self) -> int:
        return 2  # √Ñu√üerer und innerer Radius
    
    def get_handle(self, index: int) -> Tuple[float, float]:
        center_x = self.x + self.outer_radius
        center_y = self.y + self.outer_radius
        
        if index == 0:    # √Ñu√üerer Radius (oben)
            return (center_x, center_y + self.outer_radius)
        elif index == 1:  # Innerer Radius (rechts)
            return (center_x + self.inner_radius, center_y)
        else:
            raise IndexError(f"Handle index {index} out of range")
    
    def move_handle(self, index: int, world_x: float, world_y: float) -> None:
        center_x = self.x + self.outer_radius
        center_y = self.y + self.outer_radius
        
        if index == 0:    # √Ñu√üerer Radius
            self.outer_radius = abs(world_y - center_y)
        elif index == 1:  # Innerer Radius
            self.inner_radius = abs(world_x - center_x)
        
        # Position anpassen
        self.x = center_x - self.outer_radius
        self.y = center_y - self.outer_radius
        self.width = self.height = 2 * self.outer_radius
```

---

# üåü **POLYMORPHISMUS** ‚≠ê‚≠ê‚≠ê **(SEHR KLAUSURRELEVANT)**

## **Dynamic Dispatch in Aktion** ‚≠ê‚≠ê‚≠ê

```python
def render_scene(shapes: List[VectorShape], painter: QPainter, viewport: dict, pixel_size: tuple):
    """Polymorphe Szenen-Renderung"""
    for shape in shapes:
        shape.draw(painter, viewport, pixel_size)  # Ruft die richtige draw()-Methode auf!
        
        # Handles f√ºr selektierte Shapes
        if shape.selected:
            draw_handles(shape, painter, viewport, pixel_size)

def draw_handles(shape: VectorShape, painter: QPainter, viewport: dict, pixel_size: tuple):
    """Zeichnet Handles f√ºr beliebige Shape"""
    painter.setPen(QPen(QColor(255, 0, 0), 2))
    painter.setBrush(QBrush(QColor(255, 0, 0)))
    
    for i in range(shape.get_num_handles()):  # Polymorphe Methode!
        handle_x, handle_y = shape.get_handle(i)  # Polymorphe Methode!
        pixel_x, pixel_y = world_to_pixel(handle_x, handle_y, viewport, pixel_size)
        painter.drawEllipse(pixel_x - 3, pixel_y - 3, 6, 6)

def find_hit_shape(shapes: List[VectorShape], world_x: float, world_y: float) -> VectorShape:
    """Findet getroffene Shape"""
    for shape in reversed(shapes):  # R√ºckw√§rts = oberste zuerst
        if shape.is_hit(world_x, world_y):  # Polymorphe Methode!
            return shape
    return None
```

## **Warum Polymorphismus?** ‚≠ê‚≠ê‚≠ê

### **Ohne Polymorphismus (schlecht):**
```python
def render_scene_bad(shapes: List[dict]):
    for shape in shapes:
        if shape['type'] == 'rectangle':
            draw_rectangle(shape, painter, viewport, pixel_size)
        elif shape['type'] == 'circle':
            draw_circle(shape, painter, viewport, pixel_size)
        elif shape['type'] == 'star':
            draw_star(shape, painter, viewport, pixel_size)
        # F√ºr jede neue Shape: Code hier √§ndern!
```

### **Mit Polymorphismus (gut):**
```python
def render_scene_good(shapes: List[VectorShape]):
    for shape in shapes:
        shape.draw(painter, viewport, pixel_size)  # Automatisch richtige Methode!
        # Neue Shapes: Kein Code hier √§ndern!
```

---

# üõ†Ô∏è **HANDLE-SYSTEM F√úR INTERAKTION** ‚≠ê‚≠ê‚≠ê

## **Interaktive Transformationen** ‚≠ê‚≠ê‚≠ê

```python
class InteractiveDrawingWidget(QWidget):
    def __init__(self):
        super().__init__()
        self.shapes: List[VectorShape] = []
        self.selected_shape = None
        self.selected_handle = None
        self.dragging = False
        
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            world_x, world_y = self.pixel_to_world(event.pos().x(), event.pos().y())
            
            # Erst pr√ºfen: Handle angeklickt?
            closest_shape, closest_handle = self.find_closest_handle(world_x, world_y)
            
            if closest_shape and closest_handle is not None:
                # Handle-Transformation starten
                self.selected_shape = closest_shape
                self.selected_handle = closest_handle
                self.dragging = True
            else:
                # Shape-Selektion
                hit_shape = self.find_hit_shape(world_x, world_y)
                
                # Alle deselektieren
                for shape in self.shapes:
                    shape.selected = False
                
                # Getroffene Shape selektieren
                if hit_shape:
                    hit_shape.selected = True
                    self.selected_shape = hit_shape
                
            self.update()
    
    def mouseMoveEvent(self, event):
        if self.dragging and self.selected_shape and self.selected_handle is not None:
            world_x, world_y = self.pixel_to_world(event.pos().x(), event.pos().y())
            
            # Handle verschieben (polymorphe Methode!)
            self.selected_shape.move_handle(self.selected_handle, world_x, world_y)
            self.update()
    
    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.dragging = False
            self.selected_handle = None
    
    def find_closest_handle(self, world_x: float, world_y: float) -> Tuple[VectorShape, int]:
        """Findet das n√§chste Handle"""
        min_distance = float('inf')
        closest_shape = None
        closest_handle = None
        
        for shape in self.shapes:
            if shape.selected:  # Nur selektierte Shapes haben sichtbare Handles
                for i in range(shape.get_num_handles()):
                    handle_x, handle_y = shape.get_handle(i)
                    distance = math.sqrt((world_x - handle_x)**2 + (world_y - handle_y)**2)
                    
                    if distance < min_distance:
                        min_distance = distance
                        closest_shape = shape
                        closest_handle = i
        
        # Nur zur√ºckgeben wenn Handle nah genug
        if min_distance < 0.1:  # Tolerance in Weltkoordinaten
            return closest_shape, closest_handle
        
        return None, None
```

---

# üèóÔ∏è **SOLID PRINCIPLES** ‚≠ê‚≠ê‚≠ê **(SEHR KLAUSURRELEVANT)**

## **S - Single Responsibility Principle** ‚≠ê‚≠ê‚≠ê

```python
# ‚úÖ GUT: Jede Klasse hat eine Verantwortlichkeit
class Rectangle(VectorShape):
    def __init__(self, x, y, width, height):
        # NUR verantwortlich f√ºr Rechteck-Daten
        pass
    
    def draw(self, painter, viewport, pixel_size):
        # NUR verantwortlich f√ºr Rechteck-Zeichnung
        pass
    
    def is_hit(self, world_x, world_y):
        # NUR verantwortlich f√ºr Rechteck-Hit-Test
        pass

# ‚ùå SCHLECHT: Mehrere Verantwortlichkeiten
class BadRectangle:
    def __init__(self, x, y, width, height):
        self.x, self.y = x, y
        self.width, self.height = width, height
    
    def draw(self, painter):
        pass
    
    def save_to_file(self, filename):        # ‚ùå Dateiverwaltung
        pass
    
    def send_over_network(self, socket):     # ‚ùå Netzwerk-Kommunikation
        pass
    
    def calculate_taxes(self):               # ‚ùå Gesch√§ftslogik
        pass
```

## **O - Open/Closed Principle** ‚≠ê‚≠ê‚≠ê

```python
# ‚úÖ GUT: Erweiterung ohne √Ñnderung bestehenden Codes
class Triangle(VectorShape):  # NEUE Klasse hinzuf√ºgen
    def __init__(self, x, y, p1, p2, p3):
        super().__init__(x, y, 0, 0)  # Berechne Bounding Box
        self.p1, self.p2, self.p3 = p1, p2, p3
    
    def draw(self, painter, viewport, pixel_size):
        # Triangle-spezifische Implementierung
        points = [self.p1, self.p2, self.p3]
        pixel_points = []
        for px, py in points:
            pixel_x, pixel_y = world_to_pixel(px, py, viewport, pixel_size)
            pixel_points.append(QPointF(pixel_x, pixel_y))
        
        polygon = QPolygonF(pixel_points)
        painter.drawPolygon(polygon)
    
    def is_hit(self, world_x, world_y):
        # Triangle-spezifischer Hit-Test
        return point_in_triangle(world_x, world_y, self.p1, self.p2, self.p3)
    
    # ... weitere Methoden

# Bestehender Code muss NICHT ge√§ndert werden:
# - VectorShape: Unver√§ndert
# - Rectangle: Unver√§ndert  
# - Circle: Unver√§ndert
# - render_scene(): Funktioniert automatisch mit Triangle!
```

## **L - Liskov Substitution Principle** ‚≠ê‚≠ê

```python
# ‚úÖ GUT: Jede Unterklasse kann die Basisklasse ersetzen
def test_shape(shape: VectorShape):
    """Funktioniert mit JEDER VectorShape-Unterklasse"""
    shape.draw(painter, viewport, pixel_size)  # Muss bei allen funktionieren
    
    if shape.is_hit(1.0, 1.0):  # Muss bei allen bool zur√ºckgeben
        print("Hit!")
    
    handles = shape.get_num_handles()  # Muss bei allen int zur√ºckgeben
    for i in range(handles):
        x, y = shape.get_handle(i)  # Muss bei allen tuple zur√ºckgeben

# Funktioniert mit allen Unterklassen:
test_shape(Rectangle(0, 0, 2, 1))  # ‚úÖ
test_shape(Circle(0, 0, 1))        # ‚úÖ
test_shape(Star(0, 0, 1, 0.5))     # ‚úÖ
test_shape(Triangle(0, 0, p1, p2, p3))  # ‚úÖ
```

## **I - Interface Segregation Principle** ‚≠ê‚≠ê

```python
# ‚úÖ GUT: Aufgeteilte, fokussierte Interfaces
class Drawable(ABC):
    @abstractmethod
    def draw(self, painter, viewport, pixel_size): pass

class Selectable(ABC):
    @abstractmethod
    def is_hit(self, world_x, world_y): pass
    @abstractmethod
    def get_bounding_box(self): pass

class Transformable(ABC):
    @abstractmethod
    def get_num_handles(self): pass
    @abstractmethod
    def get_handle(self, index): pass
    @abstractmethod
    def move_handle(self, index, world_x, world_y): pass

class VectorShape(Drawable, Selectable, Transformable):
    # Kombiniert alle Interfaces
    pass

# Clients k√∂nnen spezifische Interfaces verwenden:
def render_only(drawable: Drawable):
    drawable.draw(painter, viewport, pixel_size)

def select_only(selectable: Selectable):
    if selectable.is_hit(1.0, 1.0):
        return selectable.get_bounding_box()
```

## **D - Dependency Inversion Principle** ‚≠ê‚≠ê

```python
# ‚úÖ GUT: Abh√§ngigkeit von Abstraktionen
class VectorGraphicsArea(QWidget):
    def __init__(self, shapes: List[VectorShape]):  # Abstraktion!
        super().__init__()
        self.shapes = shapes  # Nicht von konkreten Klassen abh√§ngig
    
    def add_shape(self, shape: VectorShape):  # Abstraktion!
        self.shapes.append(shape)  # Funktioniert mit allen Unterklassen
    
    def render(self):
        for shape in self.shapes:
            shape.draw(painter, viewport, pixel_size)  # Polymorphie!

# ‚ùå SCHLECHT: Abh√§ngigkeit von konkreten Klassen
class BadVectorGraphicsArea(QWidget):
    def __init__(self):
        super().__init__()
        self.rectangles = []     # ‚ùå Konkrete Klasse
        self.circles = []        # ‚ùå Konkrete Klasse
        self.stars = []          # ‚ùå Konkrete Klasse
    
    def add_rectangle(self, rect: Rectangle):  # ‚ùå Konkrete Klasse
        self.rectangles.append(rect)
    
    def add_circle(self, circle: Circle):      # ‚ùå Konkrete Klasse
        self.circles.append(circle)
    
    def render(self):
        for rect in self.rectangles:    # ‚ùå Verschiedene Behandlung
            rect.draw(painter, viewport, pixel_size)
        for circle in self.circles:     # ‚ùå Verschiedene Behandlung
            circle.draw(painter, viewport, pixel_size)
        for star in self.stars:         # ‚ùå Verschiedene Behandlung
            star.draw(painter, viewport, pixel_size)
```

---

# üéØ **KLAUSUR-TYPISCHE FRAGEN**

## **Theoretische Fragen** ‚≠ê‚≠ê‚≠ê

### **1. Erkl√§ren Sie alle 5 SOLID Principles mit Beispielen**
**Musterl√∂sung:**
- **S**: Eine Klasse = eine Verantwortlichkeit (Rectangle nur f√ºr Rechteck-Logik)
- **O**: Erweiterbar ohne √Ñnderung (neue Shape-Klasse hinzuf√ºgen)
- **L**: Unterklassen ersetzen Basisklasse (jede Shape in render_scene verwendbar)
- **I**: Fokussierte Interfaces (Drawable, Selectable, Transformable getrennt)
- **D**: Abh√§ngigkeit von Abstraktionen (VectorShape statt Rectangle)

### **2. Was ist Dynamic Dispatch und wie funktioniert es?**
**Musterl√∂sung:**
- Automatische Auswahl der richtigen Methode basierend auf Objekttyp
- Zur Laufzeit wird entschieden: Rectangle.draw() oder Circle.draw()
- Erm√∂glicht Polymorphismus ohne if-elif-Ketten
- Python nutzt Method Resolution Order (MRO)

### **3. Warum ist das Handle-System besser als direkte Koordinaten-Manipulation?**
**Musterl√∂sung:**
- Einheitliche Schnittstelle f√ºr alle Shapes
- Benutzerfreundliche Interaktion (visuelle Handles)
- Shape-spezifische Transformationslogik gekapselt
- Polymorphie: Gleicher Code f√ºr alle Shape-Typen

## **Praktische Aufgaben** ‚≠ê‚≠ê‚≠ê

### **1. Implementieren Sie eine neue Shape-Klasse**
```python
class Ellipse(VectorShape):
    def __init__(self, x, y, width, height):
        super().__init__(x, y, width, height)
        self.rx = width / 2   # X-Radius
        self.ry = height / 2  # Y-Radius
    
    def draw(self, painter, viewport, pixel_size):
        # Ihre Implementierung
        pass
    
    def is_hit(self, world_x, world_y):
        # Ellipsen-Hit-Test: (x-cx)¬≤/rx¬≤ + (y-cy)¬≤/ry¬≤ ‚â§ 1
        pass
    
    def get_num_handles(self):
        return 4  # 4 Seiten
    
    def get_handle(self, index):
        # Ihre Implementierung
        pass
    
    def move_handle(self, index, world_x, world_y):
        # Ihre Implementierung
        pass
```

### **2. Implementieren Sie eine Factory-Klasse**
```python
class ShapeFactory:
    @staticmethod
    def create_shape(shape_type: str, **kwargs) -> VectorShape:
        if shape_type.lower() == 'rectangle':
            return Rectangle(**kwargs)
        elif shape_type.lower() == 'circle':
            return Circle(**kwargs)
        elif shape_type.lower() == 'star':
            return Star(**kwargs)
        else:
            raise ValueError(f"Unknown shape type: {shape_type}")
    
    @staticmethod
    def get_available_shapes() -> List[str]:
        return ['rectangle', 'circle', 'star']
```

### **3. Implementieren Sie Hit-Testing mit Priorit√§ten**
```python
def find_hit_shape_with_priority(shapes: List[VectorShape], world_x: float, world_y: float) -> VectorShape:
    """Findet oberste getroffene Shape"""
    # Ihre Implementierung (von hinten nach vorne)
    pass
```

---

# üîó **NAVIGATION**

- [‚Üê Zur√ºck zu: Vektorgrafik Prozedural](4.%20Vektorgrafik%20Prozedural.md)
- [Zur √úbersicht](0.%20Index.md)
- [Weiter zu: Funktional ‚Üí](6.%20Funktional.md)
- [Sprung zu: Paradigmen ‚Üí](2.%20Paradigmen.md)

---

# üìù **ZUSAMMENFASSUNG**

## **Wichtigste Punkte f√ºr die Klausur:**
1. **Abstrakte Klassen**: Gemeinsame Schnittstelle, @abstractmethod
2. **Polymorphismus**: Gleicher Code, verschiedene Implementierungen
3. **SOLID Principles**: Alle 5 mit Beispielen erkl√§ren k√∂nnen
4. **Handle-System**: Einheitliche Transformation f√ºr alle Shapes
5. **Dynamic Dispatch**: Automatische Methodenauswahl zur Laufzeit

## **Typische Klausurfragen:**
- Neue Shape-Klasse implementieren
- SOLID Principles mit Beispielen erkl√§ren
- Polymorphismus vs. if-elif-Ketten
- Handle-System erweitern
- Factory Pattern implementieren

## **H√§ufige Fehler vermeiden:**
- `super().__init__()` nicht vergessen
- Alle abstrakten Methoden implementieren
- Handle-Indices konsistent (0-basiert)
- Bounding Box korrekt berechnen
- Y-Koordinaten in Weltkoordinaten beachten