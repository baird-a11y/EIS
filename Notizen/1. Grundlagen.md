# üìñ **1. PROGRAMMIERSPRACHEN & GRUNDLAGEN**

[‚Üê Zur√ºck zur √úbersicht](0.%20Index.md) | [Weiter zu: Paradigmen ‚Üí](2.%20Paradigmen.md)

---

# üéØ **LERNZIELE**
- 4 Programmiersprachen verstehen und vergleichen
- Performance-Unterschiede erkl√§ren k√∂nnen
- Rekursion vs. Iteration beherrschen
- Primzahltest-Algorithmus implementieren

---

# üåç **VIER PROGRAMMIERSPRACHEN IM VERGLEICH**

## **Performance-Ranking** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

```
C++ >> Java ‚âà Scala >>> Python
```

**Konkrete Zahlen (Matrix-Multiplikation 500√ó500):**
- C++: 1.3 Sekunden
- Java: 1.5 Sekunden  
- Scala: 1.6 Sekunden
- Python: 44 Sekunden (35x langsamer!)

## **Sprachen-Eigenschaften Tabelle** ‚≠ê‚≠ê‚≠ê

| Sprache | Typ | Speicher | Typisierung | Hauptvorteil | Hauptnachteil |
|---------|-----|----------|-------------|--------------|---------------|
| **C++** | Kompiliert | Manuell | Statisch | Maximale Performance | Fehleranf√§llig |
| **Java** | Kompiliert ‚Üí JVM | GC | Statisch | Plattformunabh√§ngig | JVM-Overhead |
| **Scala** | Kompiliert ‚Üí JVM | GC | Statisch | Funktional + OOP | Komplexe Syntax |
| **Python** | Interpretiert | GC | Dynamisch | Einfach zu lernen | Langsam |

## **Warum ist C++ so viel schneller?** ‚≠ê‚≠ê

### **1. Direkter Maschinencode**
```cpp
// C++: Wird direkt zu Maschinencode kompiliert
int add(int a, int b) {
    return a + b;  // MOV, ADD Assembly-Instruktionen
}
```

### **2. Statische Typisierung**
```cpp
int x = 5;  // Compiler wei√ü: x ist immer ein 32-bit Integer
```

```python
x = 5  # Python muss zur Laufzeit pr√ºfen: Ist x noch ein int?
```

### **3. Kein Garbage Collector**
```cpp
// C++: Speicher wird sofort freigegeben
{
    int* ptr = new int(42);
    delete ptr;  // Sofort frei
}
```

```python
# Python: Garbage Collector l√§uft irgendwann im Hintergrund
x = [1, 2, 3]  # Wann wird das freigegeben? Unbekannt!
```

---

# üßÆ **PRIMZAHLTEST-ALGORITHMUS**

## **Grundalgorithmus** ‚≠ê‚≠ê‚≠ê **(SEHR KLAUSURRELEVANT)**

```python
def ist_primzahl(n: int) -> bool:
    """Optimierter Primzahltest"""
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:  # Alle geraden Zahlen > 2 sind keine Primzahlen
        return False
    
    # Nur ungerade Zahlen von 3 bis ‚àön pr√ºfen
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            return False
    
    return True
```

## **Warum nur bis ‚àön pr√ºfen?** ‚≠ê‚≠ê

**Mathematischer Beweis:**
```
Wenn n = a √ó b und a ‚â§ b
Dann ist a ‚â§ ‚àön ‚â§ b

Beispiel: n = 100 = 4 √ó 25
‚àö100 = 10
4 ‚â§ 10 ‚â§ 25 ‚úì
```

**Klausur-Testzahl**: 10.007 √ó 100.003 = 1.000.700.021

## **Performance-Optimierungen** ‚≠ê‚≠ê

### **1. Nur ungerade Zahlen testen**
```python
# Schlecht: Alle Zahlen
for i in range(2, int(n**0.5) + 1):  # 2, 3, 4, 5, 6, 7, 8, 9, 10, ...

# Besser: Nur ungerade nach 2
for i in range(3, int(n**0.5) + 1, 2):  # 3, 5, 7, 9, 11, ...
```

### **2. Spezialf√§lle abfangen**
```python
# H√§ufige F√§lle zuerst pr√ºfen
if n < 2: return False        # 0, 1
if n == 2: return True        # Einzige gerade Primzahl
if n % 2 == 0: return False   # Alle anderen geraden Zahlen
```

---

# üîÑ **REKURSION VS. ITERATION**

## **Fibonacci-Beispiel** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

### **Rekursive L√∂sung (SCHLECHT!)**
```python
def fibonacci_rekursiv(n):
    if n <= 1:
        return n
    return fibonacci_rekursiv(n-1) + fibonacci_rekursiv(n-2)

# Zeitkomplexit√§t: O(2^n) - EXPONENTIELL!
# fibonacci_rekursiv(40) braucht Sekunden
```

### **Iterative L√∂sung (GUT!)**
```python
def fibonacci_iterativ(n):
    if n <= 1:
        return n
    
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    
    return b

# Zeitkomplexit√§t: O(n) - LINEAR!
# fibonacci_iterativ(1000) ist sofort fertig
```

## **Wann Rekursion verwenden?** ‚≠ê‚≠ê

### **Gut f√ºr Rekursion:**
- **Baumstrukturen**: Dateisystem, HTML-Parser
- **Divide & Conquer**: Quicksort, Mergesort
- **Mathematische Definitionen**: Fakult√§t, Binomialkoeffizienten

### **Schlecht f√ºr Rekursion:**
- **Lineare Probleme**: Fibonacci, Summen
- **Gro√üe Datenmengen**: Stack Overflow Gefahr
- **Performance-kritisch**: Funktionsaufruf-Overhead

---

# üéØ **KLAUSUR-TYPISCHE FRAGEN**

## **Theoretische Fragen** ‚≠ê‚≠ê‚≠ê

### **1. Warum ist C++ schneller als Python?**
**Musterl√∂sung:**
- C++ wird zu Maschinencode kompiliert, Python interpretiert
- C++ hat statische Typisierung, Python dynamische
- C++ hat manuelles Speichermanagement, Python Garbage Collection
- C++ hat direkten Speicherzugriff, Python Objekt-Overhead

### **2. Wann sollte man Rekursion verwenden?**
**Musterl√∂sung:**
- F√ºr Probleme mit rekursiver Struktur (B√§ume, Graphen)
- Wenn iterative L√∂sung komplizierter w√§re
- NICHT f√ºr lineare Probleme wie Fibonacci
- NICHT bei gro√üen Datenmengen (Stack Overflow)

### **3. Erkl√§re das Prinzip "nur bis ‚àön" beim Primzahltest**
**Musterl√∂sung:**
- Wenn n einen Teiler > ‚àön hat, muss es auch einen < ‚àön geben
- Mathematisch: n = a √ó b, wenn a > ‚àön dann b < ‚àön
- Spart etwa 50% der Rechenzeit

## **Praktische Aufgaben** ‚≠ê‚≠ê‚≠ê

### **1. Implementiere Primzahltest**
```python
def ist_primzahl(n: int) -> bool:
    # Deine Implementierung hier
    pass
```

### **2. Optimiere Fibonacci (iterativ)**
```python
def fibonacci(n: int) -> int:
    # Deine Implementierung hier
    pass
```

### **3. Countdown-Programm in allen Sprachen**
```python
# Python
for i in range(10, 0, -1):
    print(i)
print("Liftoff!")
```

---

# üìä **PERFORMANCE-MESSUNGEN**

## **Benchmark-Ergebnisse** ‚≠ê‚≠ê

### **Primzahltest (n = 1.000.700.021)**
```
C++:    0.08 Sekunden
Java:   0.12 Sekunden
Scala:  0.15 Sekunden
Python: 35.2 Sekunden
```

### **Fibonacci (n = 40)**
```
Rekursiv:  8.5 Sekunden
Iterativ:  0.0001 Sekunden  (85.000x schneller!)
```

### **Matrix-Multiplikation (200√ó200)**
```
C++ (optimiert):  80 ms
Python (standard): 2800 ms  (35x langsamer)
```

---

# üîó **NAVIGATION**

- [‚Üê Zur√ºck zur √úbersicht](0.%20Index.md)
- [Weiter zu: Paradigmen ‚Üí](2.%20Paradigmen.md)
- [Sprung zu: GUI-Programmierung ‚Üí](3.%20GUIs.md)
- [Sprung zu: Cheat Sheet ‚Üí](eis_cheatsheet.md)

---

# üìù **ZUSAMMENFASSUNG**

## **Wichtigste Punkte f√ºr die Klausur:**
1. **C++ >> Java ‚âà Scala >>> Python** (Performance)
2. **Rekursion vermeiden** bei linearen Problemen
3. **Primzahltest nur bis ‚àön** pr√ºfen
4. **Warum C++ schnell ist**: Kompiliert + Statisch + Manueller Speicher
5. **Warum Python langsam ist**: Interpretiert + Dynamisch + GC

## **Typische Klausurfragen:**
- Primzahltest implementieren
- Fibonacci iterativ vs. rekursiv
- Performance-Unterschiede erkl√§ren
- Wann welche Sprache verwenden?