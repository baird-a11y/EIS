# üìñ **1. PROGRAMMIERSPRACHEN & GRUNDLAGEN**

[‚Üê Zur√ºck zur √úbersicht](0.%20Index.md) | [Weiter zu: Paradigmen ‚Üí](2.%20Paradigmen.md)

---

# üéØ **LERNZIELE**

- 4 Programmiersprachen verstehen und vergleichen
- **Typsysteme und Type Checking verstehen**
- Performance-Unterschiede erkl√§ren k√∂nnen
- Rekursion vs. Iteration beherrschen
- Primzahltest-Algorithmus implementieren
- **Type Annotations in Python korrekt verwenden**

---

# üåç **VIER PROGRAMMIERSPRACHEN IM VERGLEICH**

## **Performance-Ranking** **(KLAUSURRELEVANT)**

```
C++ >> Java ‚âà Scala >>> Python
```

**Konkrete Zahlen (Matrix-Multiplikation 500√ó500):**

- C++: 1.3 Sekunden
- Java: 1.5 Sekunden
- Scala: 1.6 Sekunden
- Python: 44 Sekunden (35x langsamer!)

## **Erweiterte Sprachen-Eigenschaften Tabelle** 

| Sprache    | Typ           | Speicher | Typisierung | Kompilierung    | Type Check        | Hauptvorteil         | Hauptnachteil   |
| ---------- | ------------- | -------- | ----------- | --------------- | ----------------- | -------------------- | --------------- |
| **C++**    | Kompiliert    | Manuell  | Statisch    | ‚Üí Maschinencode | Compile-Zeit      | Maximale Performance | Fehleranf√§llig  |
| **Java**   | Kompiliert    | GC       | Statisch    | ‚Üí JVM Bytecode  | Compile-Zeit      | Plattformunabh√§ngig  | JVM-Overhead    |
| **Scala**  | Kompiliert    | GC       | Statisch    | ‚Üí JVM Bytecode  | Compile-Zeit      | Funktional + OOP     | Komplexe Syntax |
| **Python** | Interpretiert | GC       | Dynamisch   | Keine           | Laufzeit (+ MyPy) | Einfach zu lernen    | Langsam         |

## Typsysteme im Detail 

### **Statische Typisierung (C++, Java, Scala)**

```scala
// Scala: Typ wird zur Compile-Zeit gepr√ºft
var x: Int = 42
x = "Hello"  // COMPILER ERROR! Type mismatch

// Type Inference: Compiler findet Typ selbst
val y = 42  // Compiler wei√ü: y ist Int
```

### **Dynamische Typisierung (Python)**

```python
# Python: Typ wird zur Laufzeit gepr√ºft
x = 42
x = "Hello"  # Kein Problem! Variable kann Typ √§ndern

# Duck Typing: "If it walks like a duck..."
def make_sound(animal):
    animal.quack()  # Funktioniert mit allem, was quack() hat
```

## Python Type Annotations & MyPy 

### **Type Annotations Grundlagen**

```python
from typing import List, Dict, Optional, Union

# Basis-Annotations
def greet(name: str) -> str:
    return f"Hello, {name}"

# Collections mit Typen
def sum_numbers(numbers: List[int]) -> int:
    return sum(numbers)

# Union Types (mehrere m√∂gliche Typen)
def process(value: Union[int, float]) -> float:
    return float(value * 2)

# Optional (kann None sein)
def find_user(id: int) -> Optional[str]:
    if id > 0:
        return "User123"
    return None
```

### **WICHTIG: Python ignoriert Type Annotations!**

```python
def add(a: int, b: int) -> int:
    return a + b

# Das funktioniert trotzdem:
result = add("Hello", "World")  # Python: "HelloWorld"
# MyPy w√ºrde hier einen Fehler melden!
```

### **MyPy - Der Type Checker** 

```bash
# Installation
pip install mypy

# Verwendung
mypy mein_programm.py

# MyPy meldet Type-Fehler VOR der Ausf√ºhrung!
```

## isinstance() vs Type Annotations

### **isinstance() - Runtime Type Checking**

```python
def process_value(x: object) -> str:
    # isinstance() pr√ºft zur LAUFZEIT
    if isinstance(x, str):
        return x.upper()
    elif isinstance(x, int):
        return str(x * 2)
    else:
        raise TypeError("Nur str oder int erlaubt")

# MyPy erkennt isinstance() und passt Typen an!
```

### **Type Narrowing mit assert**

```python
from typing import Optional

def get_length(x: Optional[str]) -> int:
    assert x is not None  # MyPy versteht: x ist jetzt str
    return len(x)
```

## Scala Option vs. Python None

### **Python: None kann √ºberall auftauchen**

```python
def find_max(numbers: List[int]) -> Optional[int]:
    if not numbers:
        return None
    return max(numbers)

# Gefahr: NoneType Errors
result = find_max([])
print(result + 10)  # Runtime Error: NoneType + int
```

### **Scala: Option[T] erzwingt Behandlung**

```scala
def findMax(numbers: List[Int]): Option[Int] = {
    if (numbers.isEmpty) None
    else Some(numbers.max)
}

// Pattern Matching erzwingt Behandlung beider F√§lle
findMax(List()) match {
    case Some(value) => println(s"Max: $value")
    case None => println("Liste war leer")
}
```

## Warum ist C++ so viel schneller?

### **1. Direkter Maschinencode**

```cpp
// C++: Wird direkt zu Maschinencode kompiliert
int add(int a, int b) {
    return a + b;  // MOV, ADD Assembly-Instruktionen
}
```

### **2. Statische Typisierung**

```cpp
int x = 5;  // Compiler wei√ü: x ist immer ein 32-bit Integer
```

```python
x = 5  # Python muss zur Laufzeit pr√ºfen: Ist x noch ein int?
```

### **3. Kein Garbage Collector**

```cpp
// C++: Speicher wird sofort freigegeben
{
    int* ptr = new int(42);
    delete ptr;  // Sofort frei
}
```

```python
# Python: Garbage Collector l√§uft irgendwann im Hintergrund
x = [1, 2, 3]  # Wann wird das freigegeben? Unbekannt!
```

---

# üßÆ **PRIMZAHLTEST-ALGORITHMUS**

## **Grundalgorithmus** ‚≠ê‚≠ê‚≠ê **(SEHR KLAUSURRELEVANT)**

```python
def ist_primzahl(n: int) -> bool:
    """Optimierter Primzahltest"""
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:  # Alle geraden Zahlen > 2 sind keine Primzahlen
        return False
    
    # Nur ungerade Zahlen von 3 bis ‚àön pr√ºfen
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            return False
    
    return True
```

## **Warum nur bis ‚àön pr√ºfen?** ‚≠ê‚≠ê

**Mathematischer Beweis:**

```
Wenn n = a √ó b und a ‚â§ b
Dann ist a ‚â§ ‚àön ‚â§ b

Beispiel: n = 100 = 4 √ó 25
‚àö100 = 10
4 ‚â§ 10 ‚â§ 25 ‚úì
```

**Klausur-Testzahl**: 10.007 √ó 100.003 = 1.000.700.021

---

# üîÑ **REKURSION VS. ITERATION**

## **Fibonacci-Beispiel** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

### **Rekursive L√∂sung (SCHLECHT!)**

```python
def fibonacci_rekursiv(n: int) -> int:
    if n <= 1:
        return n
    return fibonacci_rekursiv(n-1) + fibonacci_rekursiv(n-2)

# Zeitkomplexit√§t: O(2^n) - EXPONENTIELL!
# fibonacci_rekursiv(40) braucht Sekunden
```

### **Iterative L√∂sung (GUT!)**

```python
def fibonacci_iterativ(n: int) -> int:
    if n <= 1:
        return n
    
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    
    return b

# Zeitkomplexit√§t: O(n) - LINEAR!
# fibonacci_iterativ(1000) ist sofort fertig
```

---

# üéØ **KLAUSUR-TYPISCHE FRAGEN**

## Type System Fragen

### **1. Was ist der Unterschied zwischen MyPy und isinstance()?**

**Musterl√∂sung:**

- **MyPy**: Statische Analyse VOR Ausf√ºhrung, pr√ºft Type Annotations
- **isinstance()**: Runtime-Check W√ÑHREND Ausf√ºhrung
- MyPy findet Fehler fr√ºher, isinstance() kann dynamische Typen pr√ºfen

### **2. Warum ignoriert Python Type Annotations?**

**Musterl√∂sung:**

- Python ist dynamisch typisiert
- Type Annotations sind nur "Hints" f√ºr Tools wie MyPy
- Abw√§rtskompatibilit√§t mit √§lterem Code
- Duck Typing Philosophie: "If it walks like a duck..."

### **3. Erkl√§re Vor- und Nachteile von Duck Typing**

**Musterl√∂sung:**

- **Vorteile**: Flexibel, weniger Code, polymorphe Funktionen
- **Nachteile**: Laufzeitfehler, schwerer zu debuggen, keine IDE-Unterst√ºtzung
- **L√∂sung**: Type Annotations + MyPy f√ºr beste aus beiden Welten

## Praktische Type Annotation Aufgaben

### **1. Schreibe korrekte Type Annotations**

```python
from typing import List, Dict, Optional, Union

# Aufgabe: Erg√§nze die Type Annotations
def calculate_statistics(numbers: ___) -> ___:
    """Berechnet min, max, avg als Dictionary"""
    if not numbers:
        return None
    return {
        "min": min(numbers),
        "max": max(numbers),
        "avg": sum(numbers) / len(numbers)
    }
```

**L√∂sung:**

```python
def calculate_statistics(numbers: List[Union[int, float]]) -> Optional[Dict[str, float]]:
    # Implementation...
```

### **2. Nutze isinstance() f√ºr Type Narrowing**

```python
def format_data(data: Union[int, str, List[int]]) -> str:
    # Implementiere mit isinstance() checks
    pass
```

**L√∂sung:**

```python
def format_data(data: Union[int, str, List[int]]) -> str:
    if isinstance(data, int):
        return f"Number: {data}"
    elif isinstance(data, str):
        return f"Text: {data.upper()}"
    elif isinstance(data, list):
        return f"List with {len(data)} items"
    else:
        raise TypeError("Unexpected type")
```

---

# üìä **PERFORMANCE-MESSUNGEN**

## **Benchmark-Ergebnisse** ‚≠ê‚≠ê

### **Primzahltest (n = 1.000.700.021)**

```
C++:    0.08 Sekunden
Java:   0.12 Sekunden
Scala:  0.15 Sekunden
Python: 35.2 Sekunden
```

### **Type Checking Overhead**

```
Python (ohne Annotations): 100ms
Python (mit Annotations):  100ms  (kein Runtime-Overhead!)
MyPy Check:               500ms  (einmalig vor Ausf√ºhrung)
```

---

# üí° **WICHTIGE SYNTAX-REGELN F√úR DIE KLAUSUR**

## **Python Checkliste** ‚úì

- [ ] Doppelpunkt `:` nach def, if, for, while, class
- [ ] Einr√ºckung mit 4 Spaces (konsistent!)
- [ ] `raise` Exception, nicht `return` Exception
- [ ] `len(list)` nicht `range(list)`
- [ ] `list[i]` nicht `list(i)`
- [ ] Type Annotations: `List[int]` nicht `[List]`

## **Scala Checkliste** ‚úì

- [ ] Geschweifte Klammern `{}` f√ºr Bl√∂cke
- [ ] `def` f√ºr Funktionen, `val`/`var` f√ºr Variablen
- [ ] Option[T] mit Some/None
- [ ] Pattern Matching mit `match`
- [ ] Semikolons optional (aber in Klausur zur Sicherheit)

---

# üìù **ZUSAMMENFASSUNG**

## **Neue wichtige Punkte f√ºr die Klausur:**

1. **MyPy** ist der Type Checker f√ºr Python (NICHT isinstance!)
2. **Type Annotations** werden von Python ignoriert
3. **isinstance()** f√ºr Runtime Type Checking
4. **Scala kompiliert**, **Python interpretiert**
5. **Option[T]** ist sicherer als None/null

## **Typische Fehlerquellen:**

- Verwechslung MyPy ‚Üî isinstance()
- Falsche Exception-Syntax (raise vs return)
- Falsche List-Operationen (len, Zugriff)
- Type Annotation Syntax-Fehler