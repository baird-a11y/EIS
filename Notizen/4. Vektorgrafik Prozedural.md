# üìê **4. VEKTORGRAFIK PROZEDURAL**

[‚Üê Zur√ºck zu: GUI](3.%20GUIs.md) | [Zur √úbersicht](0.%20Index.md) | [Weiter zu: OOP ‚Üí](5.%20OOP.md)

---

# üéØ **LERNZIELE**
- Koordinaten-Transformationen beherrschen
- Stern-Mathematik mit Polarkoordinaten
- Viewport-System verstehen
- Zoom und Pan implementieren
- Prozedurale Datenstrukturen verwenden

---

# üó∫Ô∏è **KOORDINATEN-TRANSFORMATIONEN** ‚≠ê‚≠ê‚≠ê **(SEHR KLAUSURRELEVANT)**

## **Das Grundproblem**
```
Welt-Koordinaten          Pixel-Koordinaten
(mathematisch)            (Bildschirm)
     
Y                               0 -------- X
‚Üë                               |
|                               |
|                               |
0 -------- X                    Y
```

**Unterschiede:**
- **Welt**: Y nach oben, beliebiger Ursprung
- **Pixel**: Y nach unten, Ursprung links oben

## **Grundformel: Welt ‚Üí Pixel** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

```python
def world_to_pixel(world_x, world_y, viewport, pixel_size):
    """
    Transformiert Weltkoordinaten zu Pixelkoordinaten
    
    Args:
        world_x, world_y: Koordinaten in der Welt
        viewport: Dict mit world_left, world_right, world_top, world_bottom
        pixel_size: Tuple (width, height) in Pixeln
    
    Returns:
        Tuple (pixel_x, pixel_y)
    """
    pixel_width, pixel_height = pixel_size
    
    # 1. Weltkoordinaten-Bereich berechnen
    world_width = viewport['world_right'] - viewport['world_left']
    world_height = viewport['world_top'] - viewport['world_bottom']
    
    # 2. Normalisierung (0 bis 1)
    norm_x = (world_x - viewport['world_left']) / world_width
    norm_y = (world_y - viewport['world_bottom']) / world_height
    
    # 3. Skalierung auf Pixelgr√∂√üe
    pixel_x = norm_x * pixel_width
    pixel_y = (1.0 - norm_y) * pixel_height  # Y-Achse umkehren!
    
    return int(pixel_x), int(pixel_y)
```

## **Warum Y-Achse umkehren?** ‚≠ê‚≠ê‚≠ê **(H√ÑUFIGE KLAUSURFRAGE)**

```python
# Weltkoordinaten: Y nach oben
world_point = (0, 1)  # Oben im Koordinatensystem

# Pixelkoordinaten: Y nach unten
# (0, 1) in Welt = (0, 0) in Pixel (oben links)
# (0, 0) in Welt = (0, height) in Pixel (unten links)

# Daher: pixel_y = (1.0 - norm_y) * pixel_height
```

## **Umkehrung: Pixel ‚Üí Welt** ‚≠ê‚≠ê

```python
def pixel_to_world(pixel_x, pixel_y, viewport, pixel_size):
    """Transformiert Pixelkoordinaten zu Weltkoordinaten"""
    pixel_width, pixel_height = pixel_size
    
    # 1. Normalisierung (0 bis 1)
    norm_x = pixel_x / pixel_width
    norm_y = 1.0 - (pixel_y / pixel_height)  # Y-Achse umkehren!
    
    # 2. Weltkoordinaten-Bereich
    world_width = viewport['world_right'] - viewport['world_left']
    world_height = viewport['world_top'] - viewport['world_bottom']
    
    # 3. Skalierung auf Weltgr√∂√üe
    world_x = viewport['world_left'] + norm_x * world_width
    world_y = viewport['world_bottom'] + norm_y * world_height
    
    return world_x, world_y
```

---

# üîç **ZOOM UND PAN** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

## **Zoom um Mausposition** ‚≠ê‚≠ê‚≠ê

### **Das Problem:**
```
Vor Zoom: Maus zeigt auf Punkt P
Nach Zoom: Maus soll immer noch auf Punkt P zeigen
```

### **L√∂sung:**
```python
def zoom_at_mouse(self, mouse_x, mouse_y, zoom_factor):
    """Zoom mit Maus als Fokuspunkt"""
    
    # 1. Weltkoordinate unter Maus VOR Zoom
    world_point_before = pixel_to_world(
        mouse_x, mouse_y, self.viewport, (self.width(), self.height())
    )
    
    # 2. Zoom anwenden
    old_zoom = self.zoom_factor
    self.zoom_factor *= zoom_factor
    
    # 3. Viewport anpassen (kleiner bei Zoom in)
    scale_factor = old_zoom / self.zoom_factor
    center_x = (self.viewport['world_left'] + self.viewport['world_right']) / 2
    center_y = (self.viewport['world_bottom'] + self.viewport['world_top']) / 2
    
    world_width = (self.viewport['world_right'] - self.viewport['world_left']) * scale_factor
    world_height = (self.viewport['world_top'] - self.viewport['world_bottom']) * scale_factor
    
    self.viewport = {
        'world_left': center_x - world_width / 2,
        'world_right': center_x + world_width / 2,
        'world_bottom': center_y - world_height / 2,
        'world_top': center_y + world_height / 2
    }
    
    # 4. Weltkoordinate unter Maus NACH Zoom
    world_point_after = pixel_to_world(
        mouse_x, mouse_y, self.viewport, (self.width(), self.height())
    )
    
    # 5. Differenz kompensieren durch Pan
    dx = world_point_before[0] - world_point_after[0]
    dy = world_point_before[1] - world_point_after[1]
    
    self.viewport['world_left'] += dx
    self.viewport['world_right'] += dx
    self.viewport['world_bottom'] += dy
    self.viewport['world_top'] += dy
```

## **Pan (Verschieben)** ‚≠ê‚≠ê

```python
def pan(self, dx_pixels, dy_pixels):
    """Pan in Pixelkoordinaten"""
    
    # Pixel-Offset zu Welt-Offset umrechnen
    world_width = self.viewport['world_right'] - self.viewport['world_left']
    world_height = self.viewport['world_top'] - self.viewport['world_bottom']
    
    dx_world = dx_pixels * world_width / self.width()
    dy_world = -dy_pixels * world_height / self.height()  # Y umkehren!
    
    # Viewport verschieben
    self.viewport['world_left'] += dx_world
    self.viewport['world_right'] += dx_world
    self.viewport['world_bottom'] += dy_world
    self.viewport['world_top'] += dy_world
```

---

# ‚≠ê **STERN-MATHEMATIK** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

## **5-zackiger Stern = 10 Punkte** ‚≠ê‚≠ê‚≠ê

```python
def calculate_star_points(center_x, center_y, outer_radius, inner_radius, num_points=5):
    """
    Berechnet die Punkte f√ºr einen Stern
    
    Args:
        center_x, center_y: Mittelpunkt
        outer_radius: √Ñu√üerer Radius (Spitzen)
        inner_radius: Innerer Radius (Einbuchtungen)
        num_points: Anzahl Zacken
    
    Returns:
        List von (x, y) Koordinaten
    """
    points = []
    num_vertices = num_points * 2  # Doppelt so viele Punkte
    
    for i in range(num_vertices):
        # Winkel berechnen (gleichm√§√üig verteilt)
        angle = i * (2 * math.pi / num_vertices) - math.pi/2  # -œÄ/2 = Start oben
        
        # Alternierend √§u√üerer und innerer Radius
        if i % 2 == 0:
            radius = outer_radius  # Gerade Indizes = Spitzen
        else:
            radius = inner_radius  # Ungerade Indizes = Einbuchtungen
        
        # Polarkoordinaten ‚Üí Kartesische Koordinaten
        x = center_x + radius * math.cos(angle)
        y = center_y + radius * math.sin(angle)
        
        points.append((x, y))
    
    return points
```

## **Polarkoordinaten Grundlagen** ‚≠ê‚≠ê

```python
import math

# Kartesische ‚Üí Polar
def cartesian_to_polar(x, y):
    radius = math.sqrt(x*x + y*y)
    angle = math.atan2(y, x)
    return radius, angle

# Polar ‚Üí Kartesische
def polar_to_cartesian(radius, angle):
    x = radius * math.cos(angle)
    y = radius * math.sin(angle)
    return x, y
```

### **Wichtige Winkel:**
```python
# Winkel in Radiant (nicht Grad!)
0¬∞   =  0         = 0 * œÄ/180    # Rechts
90¬∞  =  œÄ/2       = 90 * œÄ/180   # Oben
180¬∞ =  œÄ         = 180 * œÄ/180  # Links
270¬∞ =  3œÄ/2      = 270 * œÄ/180  # Unten
360¬∞ =  2œÄ        = 360 * œÄ/180  # Volle Drehung
```

---

# üé® **PROZEDURALE DATENSTRUKTUREN** ‚≠ê‚≠ê

## **Shape-Representation mit Dictionaries** ‚≠ê‚≠ê

```python
def create_rectangle(x, y, width, height, fill_color=(100, 100, 255)):
    """Erstellt ein Rechteck-Dictionary"""
    return {
        'type': 'rectangle',
        'x': x,
        'y': y,
        'width': width,
        'height': height,
        'fill_color': fill_color,
        'border_color': (0, 0, 0),
        'border_width': 1.0
    }

def create_circle(x, y, radius, fill_color=(255, 100, 100)):
    """Erstellt ein Kreis-Dictionary"""
    return {
        'type': 'circle',
        'x': x,
        'y': y,
        'radius': radius,
        'fill_color': fill_color,
        'border_color': (0, 0, 0),
        'border_width': 1.0
    }

def create_star(x, y, outer_radius, inner_radius, points=5, fill_color=(255, 255, 100)):
    """Erstellt ein Stern-Dictionary"""
    return {
        'type': 'star',
        'x': x,
        'y': y,
        'outer_radius': outer_radius,
        'inner_radius': inner_radius,
        'points': points,
        'fill_color': fill_color,
        'border_color': (0, 0, 0),
        'border_width': 1.0
    }
```

## **Rendering-Funktionen** ‚≠ê‚≠ê

```python
def render_scene(shapes, painter, viewport, pixel_size):
    """Rendert eine komplette Szene"""
    for shape in shapes:
        if shape['type'] == 'rectangle':
            draw_rectangle(shape, painter, viewport, pixel_size)
        elif shape['type'] == 'circle':
            draw_circle(shape, painter, viewport, pixel_size)
        elif shape['type'] == 'star':
            draw_star(shape, painter, viewport, pixel_size)
        else:
            print(f"Unknown shape type: {shape['type']}")

def draw_rectangle(rect, painter, viewport, pixel_size):
    """Zeichnet ein Rechteck"""
    # Koordinaten transformieren
    pixel_x, pixel_y = world_to_pixel(rect['x'], rect['y'], viewport, pixel_size)
    pixel_width = world_to_pixel_size(rect['width'], viewport, pixel_size, 'width')
    pixel_height = world_to_pixel_size(rect['height'], viewport, pixel_size, 'height')
    
    # Zeichnen
    painter.setBrush(QBrush(QColor(*rect['fill_color'])))
    painter.setPen(QPen(QColor(*rect['border_color']), rect['border_width']))
    painter.drawRect(pixel_x, pixel_y, pixel_width, pixel_height)

def draw_circle(circle, painter, viewport, pixel_size):
    """Zeichnet einen Kreis"""
    # Koordinaten transformieren
    pixel_x, pixel_y = world_to_pixel(circle['x'], circle['y'], viewport, pixel_size)
    pixel_radius = world_to_pixel_size(circle['radius'], viewport, pixel_size, 'width')
    
    # Zeichnen (drawEllipse erwartet top-left corner)
    painter.setBrush(QBrush(QColor(*circle['fill_color'])))
    painter.setPen(QPen(QColor(*circle['border_color']), circle['border_width']))
    painter.drawEllipse(pixel_x - pixel_radius, pixel_y - pixel_radius, 
                       2 * pixel_radius, 2 * pixel_radius)

def draw_star(star, painter, viewport, pixel_size):
    """Zeichnet einen Stern"""
    # Stern-Punkte berechnen
    star_points = calculate_star_points(
        star['x'], star['y'], 
        star['outer_radius'], star['inner_radius'], 
        star['points']
    )
    
    # Zu Pixelkoordinaten transformieren
    pixel_points = []
    for world_x, world_y in star_points:
        pixel_x, pixel_y = world_to_pixel(world_x, world_y, viewport, pixel_size)
        pixel_points.append(QPointF(pixel_x, pixel_y))
    
    # Polygon erstellen und zeichnen
    polygon = QPolygonF(pixel_points)
    painter.setBrush(QBrush(QColor(*star['fill_color'])))
    painter.setPen(QPen(QColor(*star['border_color']), star['border_width']))
    painter.drawPolygon(polygon)
```

---

# üìè **HILFSFUNKTIONEN** ‚≠ê‚≠ê

## **Gr√∂√üen-Transformation** ‚≠ê‚≠ê

```python
def world_to_pixel_size(world_size, viewport, pixel_size, dimension='width'):
    """Konvertiert Weltgr√∂√üen zu Pixelgr√∂√üen"""
    pixel_width, pixel_height = pixel_size
    
    if dimension == 'width':
        world_width = viewport['world_right'] - viewport['world_left']
        return int(world_size * pixel_width / world_width)
    else:  # height
        world_height = viewport['world_top'] - viewport['world_bottom']
        return int(world_size * pixel_height / world_height)
```

## **Bounding Box Berechnung** ‚≠ê‚≠ê

```python
def get_shape_bounds(shape):
    """Berechnet Bounding Box f√ºr beliebige Shape"""
    if shape['type'] == 'rectangle':
        return {
            'left': shape['x'],
            'right': shape['x'] + shape['width'],
            'top': shape['y'] + shape['height'],
            'bottom': shape['y']
        }
    elif shape['type'] == 'circle':
        return {
            'left': shape['x'] - shape['radius'],
            'right': shape['x'] + shape['radius'],
            'top': shape['y'] + shape['radius'],
            'bottom': shape['y'] - shape['radius']
        }
    elif shape['type'] == 'star':
        return {
            'left': shape['x'] - shape['outer_radius'],
            'right': shape['x'] + shape['outer_radius'],
            'top': shape['y'] + shape['outer_radius'],
            'bottom': shape['y'] - shape['outer_radius']
        }
```

---

# üéØ **KLAUSUR-TYPISCHE RECHENAUFGABEN** ‚≠ê‚≠ê‚≠ê

## **Aufgabe 1: Koordinaten-Transformation** ‚≠ê‚≠ê‚≠ê

**Gegeben:**
- Viewport: `world_left=-2.0, world_right=2.0, world_top=2.0, world_bottom=-2.0`
- Pixel-Gr√∂√üe: `800√ó600`
- Welt-Punkt: `(1.0, 0.5)`

**Berechnen Sie die Pixel-Koordinaten:**

**L√∂sung:**
```python
# 1. Normalisierung
norm_x = (1.0 - (-2.0)) / (2.0 - (-2.0)) = 3.0 / 4.0 = 0.75
norm_y = (0.5 - (-2.0)) / (2.0 - (-2.0)) = 2.5 / 4.0 = 0.625

# 2. Skalierung
pixel_x = 0.75 * 800 = 600
pixel_y = (1.0 - 0.625) * 600 = 0.375 * 600 = 225

# Antwort: (600, 225)
```

## **Aufgabe 2: Stern-Punkte berechnen** ‚≠ê‚≠ê‚≠ê

**Gegeben:**
- Mittelpunkt: `(0, 0)`
- √Ñu√üerer Radius: `1.0`
- Innerer Radius: `0.5`
- 5-zackiger Stern

**Berechnen Sie die ersten 4 Punkte:**

**L√∂sung:**
```python
# Punkt 0 (i=0, √§u√üerer Radius, -œÄ/2)
angle = 0 * (2œÄ/10) - œÄ/2 = -œÄ/2
x = 0 + 1.0 * cos(-œÄ/2) = 0
y = 0 + 1.0 * sin(-œÄ/2) = -1.0
# Punkt 0: (0, -1.0)

# Punkt 1 (i=1, innerer Radius, -œÄ/2 + œÄ/5)
angle = 1 * (2œÄ/10) - œÄ/2 = œÄ/5 - œÄ/2 = -3œÄ/10
x = 0 + 0.5 * cos(-3œÄ/10) ‚âà 0.154
y = 0 + 0.5 * sin(-3œÄ/10) ‚âà -0.476
# Punkt 1: (0.154, -0.476)

# Punkt 2 (i=2, √§u√üerer Radius, -œÄ/2 + 2œÄ/5)
angle = 2 * (2œÄ/10) - œÄ/2 = 2œÄ/5 - œÄ/2 = -œÄ/10
x = 0 + 1.0 * cos(-œÄ/10) ‚âà 0.951
y = 0 + 1.0 * sin(-œÄ/10) ‚âà -0.309
# Punkt 2: (0.951, -0.309)

# Punkt 3 (i=3, innerer Radius, -œÄ/2 + 3œÄ/5)
angle = 3 * (2œÄ/10) - œÄ/2 = 3œÄ/5 - œÄ/2 = œÄ/10
x = 0 + 0.5 * cos(œÄ/10) ‚âà 0.476
y = 0 + 0.5 * sin(œÄ/10) ‚âà 0.154
# Punkt 3: (0.476, 0.154)
```

## **Aufgabe 3: Zoom-Berechnung** ‚≠ê‚≠ê

**Gegeben:**
- Alter Zoom: `1.0`
- Neuer Zoom: `2.0`
- Mausposition: `(400, 300)` (in 800√ó600 Fenster)
- Viewport vor Zoom: `[-2, 2, 2, -2]`

**Berechnen Sie neuen Viewport:**

**L√∂sung:**
```python
# 1. Mausposition zu Welt vor Zoom
norm_x = 400 / 800 = 0.5
norm_y = 1.0 - (300 / 600) = 0.5
world_x = -2.0 + 0.5 * 4.0 = 0.0
world_y = -2.0 + 0.5 * 4.0 = 0.0
# Maus zeigt auf (0, 0)

# 2. Viewport nach Zoom (halbe Gr√∂√üe)
old_width = 4.0, old_height = 4.0
new_width = 2.0, new_height = 2.0
center_x = 0.0, center_y = 0.0

new_viewport = {
    'world_left': 0.0 - 1.0 = -1.0,
    'world_right': 0.0 + 1.0 = 1.0,
    'world_bottom': 0.0 - 1.0 = -1.0,
    'world_top': 0.0 + 1.0 = 1.0
}

# 3. Mausposition zu Welt nach Zoom
world_x_after = -1.0 + 0.5 * 2.0 = 0.0
world_y_after = -1.0 + 0.5 * 2.0 = 0.0
# Maus zeigt immer noch auf (0, 0) ‚úì

# Antwort: [-1.0, 1.0, 1.0, -1.0]
```

---

# üîó **NAVIGATION**

- [‚Üê Zur√ºck zu: GUI](3.%20GUIs.md)
- [Zur √úbersicht](0.%20Index.md)
- [Weiter zu: OOP ‚Üí](5.%20OOP.md)
- [Sprung zu: Funktional ‚Üí](6.%20Funktional.md)

---

# üìù **ZUSAMMENFASSUNG**

## **Wichtigste Punkte f√ºr die Klausur:**
1. **Koordinaten-Transformation**: Normalisierung ‚Üí Skalierung ‚Üí Y-Achse umkehren
2. **Stern-Mathematik**: 2n Punkte, alternierend √§u√üerer/innerer Radius
3. **Zoom um Maus**: Weltpunkt vor/nach Zoom berechnen, Differenz ausgleichen
4. **Y-Achse**: Welt nach oben, Pixel nach unten
5. **Prozedurale Datenstrukturen**: Dictionaries f√ºr Shapes

## **Typische Klausurfragen:**
- Pixel-Koordinaten zu Welt-Koordinaten umrechnen
- Stern-Punkte mit Polarkoordinaten berechnen
- Zoom-Viewport berechnen
- Bounding Box f√ºr verschiedene Shapes
- Rendering-Pipeline implementieren

## **Formeln auswendig lernen:**
```python
# Koordinaten-Transformation
norm_x = (world_x - world_left) / world_width
pixel_x = norm_x * pixel_width
pixel_y = (1.0 - norm_y) * pixel_height

# Polarkoordinaten
x = center_x + radius * cos(angle)
y = center_y + radius * sin(angle)

# Stern-Winkel
angle = i * (2œÄ / num_vertices) - œÄ/2
```