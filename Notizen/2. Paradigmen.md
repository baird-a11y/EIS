# 🎭 **2. PROGRAMMIERPARADIGMEN**

[← Zurück zu: Grundlagen](1.%20Grundlagen.md) | [Zur Übersicht](0.%20Index.md) | [Weiter zu: GUI →](3.%20GUIs.md)

---

# 🎯 **LERNZIELE**
- Expression Problem verstehen und erklären
- Paradigmen-Trade-offs kennen
- Wann welches Paradigma verwenden
- Vor- und Nachteile aller Ansätze

---

# 🎯 **DAS EXPRESSION PROBLEM** ⭐⭐⭐ **(SEHR KLAUSURRELEVANT)**

## **Problem-Definition**
**Das zentrale Dilemma der Softwareentwicklung:**
> Wie kann man sowohl neue Datentypen als auch neue Operationen einfach hinzufügen, ohne bestehenden Code zu ändern?

## **Visualisierung des Problems**

```
           │  draw()  │ transform() │ colorize() │
───────────┼─────────┼─────────────┼────────────┤
Triangle   │   ✓     │      ✓      │     ✓      │
Circle     │   ✓     │      ✓      │     ✓      │
Rectangle  │   ✓     │      ✓      │     ✓      │
Group      │   ✓     │      ✓      │     ✓      │
───────────┼─────────┼─────────────┼────────────┤
```

**Herausforderungen:**
- **Neue Zeile hinzufügen** (neuer Datentyp): `Pentagon`
- **Neue Spalte hinzufügen** (neue Operation): `rotate()`

---

# 🏗️ **PARADIGMEN-VERGLEICH**

## **1. Objektorientierter Ansatz** ⭐⭐⭐

### **Stärken: Einfach neue Datentypen hinzufügen**
```python
# Bestehender Code:
class Shape(ABC):
    @abstractmethod
    def draw(self): pass
    @abstractmethod
    def transform(self): pass
    @abstractmethod
    def colorize(self): pass

class Rectangle(Shape):
    def draw(self): print("Drawing rectangle")
    def transform(self): print("Transforming rectangle")
    def colorize(self): print("Coloring rectangle")

# NEU: Einfach neue Klasse hinzufügen
class Pentagon(Shape):  # ✅ EINFACH
    def draw(self): print("Drawing pentagon")
    def transform(self): print("Transforming pentagon")
    def colorize(self): print("Coloring pentagon")
```

### **Schwächen: Schwer neue Operationen hinzufügen**
```python
# Neue Operation hinzufügen: rotate()
class Shape(ABC):
    @abstractmethod
    def draw(self): pass
    @abstractmethod
    def transform(self): pass
    @abstractmethod
    def colorize(self): pass
    @abstractmethod
    def rotate(self): pass  # ❌ ALLE Klassen müssen erweitert werden!

# JEDE bestehende Klasse muss geändert werden:
class Rectangle(Shape):
    def draw(self): print("Drawing rectangle")
    def transform(self): print("Transforming rectangle")
    def colorize(self): print("Coloring rectangle")
    def rotate(self): print("Rotating rectangle")  # ❌ AUFWÄNDIG

class Circle(Shape):
    def draw(self): print("Drawing circle")
    def transform(self): print("Transforming circle")
    def colorize(self): print("Coloring circle")
    def rotate(self): print("Rotating circle")  # ❌ AUFWÄNDIG
```

## **2. Funktionaler Ansatz** ⭐⭐⭐

### **Stärken: Einfach neue Operationen hinzufügen**
```python
# Bestehende Datentypen
shapes = [
    {"type": "rectangle", "x": 0, "y": 0, "width": 10, "height": 5},
    {"type": "circle", "x": 5, "y": 5, "radius": 3},
    {"type": "triangle", "x": 2, "y": 2, "points": [(0,0), (5,0), (2,4)]}
]

# Bestehende Operationen
def draw(shape):
    if shape["type"] == "rectangle":
        print(f"Drawing rectangle at ({shape['x']}, {shape['y']})")
    elif shape["type"] == "circle":
        print(f"Drawing circle at ({shape['x']}, {shape['y']})")
    elif shape["type"] == "triangle":
        print(f"Drawing triangle at ({shape['x']}, {shape['y']})")

def transform(shape):
    if shape["type"] == "rectangle":
        print("Transforming rectangle")
    elif shape["type"] == "circle":
        print("Transforming circle")
    elif shape["type"] == "triangle":
        print("Transforming triangle")

# NEU: Einfach neue Operation hinzufügen
def rotate(shape):  # ✅ EINFACH
    if shape["type"] == "rectangle":
        print("Rotating rectangle")
    elif shape["type"] == "circle":
        print("Rotating circle")
    elif shape["type"] == "triangle":
        print("Rotating triangle")
```

### **Schwächen: Schwer neue Datentypen hinzufügen**
```python
# Neuer Datentyp: Pentagon
pentagon = {"type": "pentagon", "x": 0, "y": 0, "sides": 5}

# ALLE Funktionen müssen erweitert werden:
def draw(shape):
    if shape["type"] == "rectangle":
        print("Drawing rectangle")
    elif shape["type"] == "circle":
        print("Drawing circle")
    elif shape["type"] == "triangle":
        print("Drawing triangle")
    elif shape["type"] == "pentagon":  # ❌ ALLE Funktionen ändern!
        print("Drawing pentagon")

def transform(shape):
    if shape["type"] == "rectangle":
        print("Transforming rectangle")
    elif shape["type"] == "circle":
        print("Transforming circle")
    elif shape["type"] == "triangle":
        print("Transforming triangle")
    elif shape["type"] == "pentagon":  # ❌ ALLE Funktionen ändern!
        print("Transforming pentagon")
```

---

# 📊 **TRADE-OFF TABELLE** ⭐⭐⭐ **(KLAUSURRELEVANT)**

| Aspekt | Objektorientiert | Funktional | Prozedural |
|--------|------------------|------------|------------|
| **Neue Datentypen** | ✅ Einfach | ❌ Schwer | ❌ Schwer |
| **Neue Operationen** | ❌ Schwer | ✅ Einfach | ✅ Einfach |
| **Performance** | ⚠️ Overhead | ✅ Optimierbar | ✅ Direkt |
| **Parallelisierung** | ❌ Shared State | ✅ Immutable | ❌ Globals |
| **Testbarkeit** | ⚠️ Mocking | ✅ Pure Functions | ⚠️ Seiteneffekte |
| **GUI-Programmierung** | ✅ Natürlich | ❌ Kompliziert | ⚠️ Mittel |
| **Lernkurve** | ⚠️ Mittel | ❌ Steil | ✅ Einfach |
| **Code-Wiederverwendung** | ✅ Vererbung | ✅ Komposition | ❌ Copy-Paste |

---

# 🔄 **PRAKTISCHE ANWENDUNG: VEKTORGRAFIK-EDITOR**

## **Beispiel: Neue Shape hinzufügen**

### **OOP-Ansatz (Einfach):**
```python
class Star(VectorShape):  # ✅ Nur neue Klasse
    def __init__(self, x, y, outer_radius, inner_radius, points):
        super().__init__(x, y, outer_radius*2, outer_radius*2)
        self.outer_radius = outer_radius
        self.inner_radius = inner_radius
        self.points = points
    
    def draw(self, painter, viewport, pixel_size):
        # Stern-spezifische Zeichnung
        pass
    
    def is_hit(self, world_x, world_y):
        # Stern-spezifischer Hit-Test
        pass
```

### **Funktionaler Ansatz (Schwer):**
```python
# ALLE Funktionen müssen erweitert werden:
def draw_shape(shape):
    if shape["type"] == "rectangle":
        draw_rectangle(shape)
    elif shape["type"] == "circle":
        draw_circle(shape)
    elif shape["type"] == "star":  # ❌ Hier hinzufügen
        draw_star(shape)

def hit_test(shape, x, y):
    if shape["type"] == "rectangle":
        return hit_test_rectangle(shape, x, y)
    elif shape["type"] == "circle":
        return hit_test_circle(shape, x, y)
    elif shape["type"] == "star":  # ❌ Hier hinzufügen
        return hit_test_star(shape, x, y)

def get_bounding_box(shape):
    if shape["type"] == "rectangle":
        return get_rectangle_bounds(shape)
    elif shape["type"] == "circle":
        return get_circle_bounds(shape)
    elif shape["type"] == "star":  # ❌ Hier hinzufügen
        return get_star_bounds(shape)

# ... und so weiter für ALLE Funktionen
```

## **Beispiel: Neue Operation hinzufügen**

### **Funktionaler Ansatz (Einfach):**
```python
def export_svg(shapes):  # ✅ Nur neue Funktion
    svg_output = '<svg>'
    for shape in shapes:
        if shape["type"] == "rectangle":
            svg_output += f'<rect x="{shape["x"]}" y="{shape["y"]}" width="{shape["width"]}" height="{shape["height"]}" />'
        elif shape["type"] == "circle":
            svg_output += f'<circle cx="{shape["x"]}" cy="{shape["y"]}" r="{shape["radius"]}" />'
        elif shape["type"] == "star":
            svg_output += f'<polygon points="{calculate_star_points(shape)}" />'
    svg_output += '</svg>'
    return svg_output
```

### **OOP-Ansatz (Schwer):**
```python
# ALLE Klassen müssen erweitert werden:
class VectorShape(ABC):
    @abstractmethod
    def draw(self, painter, viewport, pixel_size): pass
    @abstractmethod
    def is_hit(self, world_x, world_y): pass
    @abstractmethod
    def export_svg(self): pass  # ❌ Neue abstrakte Methode

class Rectangle(VectorShape):
    def draw(self, painter, viewport, pixel_size): pass
    def is_hit(self, world_x, world_y): pass
    def export_svg(self):  # ❌ Muss implementiert werden
        return f'<rect x="{self.x}" y="{self.y}" width="{self.width}" height="{self.height}" />'

class Circle(VectorShape):
    def draw(self, painter, viewport, pixel_size): pass
    def is_hit(self, world_x, world_y): pass
    def export_svg(self):  # ❌ Muss implementiert werden
        return f'<circle cx="{self.x}" cy="{self.y}" r="{self.radius}" />'

class Star(VectorShape):
    def draw(self, painter, viewport, pixel_size): pass
    def is_hit(self, world_x, world_y): pass
    def export_svg(self):  # ❌ Muss implementiert werden
        return f'<polygon points="{self.calculate_star_points()}" />'
```

---

# 🔧 **LÖSUNGSANSÄTZE FÜR DAS EXPRESSION PROBLEM**

## **1. Visitor Pattern** ⭐⭐

### **Prinzip: Wechsel zu "funktionaler Situation"**
```python
class ShapeVisitor(ABC):
    @abstractmethod
    def visit_rectangle(self, rect): pass
    @abstractmethod
    def visit_circle(self, circle): pass
    @abstractmethod
    def visit_star(self, star): pass

class SVGExportVisitor(ShapeVisitor):  # ✅ Neue Operation als Visitor
    def visit_rectangle(self, rect):
        return f'<rect x="{rect.x}" y="{rect.y}" width="{rect.width}" height="{rect.height}" />'
    
    def visit_circle(self, circle):
        return f'<circle cx="{circle.x}" cy="{circle.y}" r="{circle.radius}" />'
    
    def visit_star(self, star):
        return f'<polygon points="{star.calculate_points()}" />'

class VectorShape(ABC):
    @abstractmethod
    def accept(self, visitor): pass

class Rectangle(VectorShape):
    def accept(self, visitor):
        return visitor.visit_rectangle(self)
```

### **Nachteile des Visitor Patterns:**
- Komplizierter als direkte Ansätze
- Trotzdem müssen alle Shapes erweitert werden für neue Visitor-Methoden
- Schwer zu verstehen und zu debuggen

## **2. Hybrid-Ansatz** ⭐⭐

### **Functional Core, Imperative Shell**
```python
# Funktional: Datenstrukturen und Transformationen
def subdivide_triangles(triangles: List[Triangle]) -> List[Triangle]:
    result = []
    for triangle in triangles:
        result.extend(subdivide_triangle(triangle))
    return result

def sine_wave_deform(triangles: List[Triangle]) -> List[Triangle]:
    return [deform_triangle(t) for t in triangles]

# OOP: GUI und Interaktion
class VectorGraphicsArea(QWidget):
    def __init__(self):
        self.shapes = []
        
    def export_svg(self):
        # Geometrie extrahieren (OOP → Funktional)
        triangles = []
        for shape in self.shapes:
            triangles.extend(shape.describe_shape())
        
        # Funktionale Transformationen
        subdivided = subdivide_triangles(triangles)
        deformed = sine_wave_deform(subdivided)
        
        # SVG-Export (Funktional)
        return export_to_svg(deformed)
```

---

# 🎯 **WANN WELCHES PARADIGMA VERWENDEN?** ⭐⭐⭐

## **Objektorientiert wählen bei:**
- **GUI-Anwendungen** (Widgets, Events)
- **Frameworks** (Plugin-Systeme)
- **Simulationen** (Objekte mit Zustand)
- **Datenbank-Mapping** (ORM)
- **Wenn neue Datentypen häufiger als neue Operationen**

### **Beispiele:**
- Spiele (Player, Enemy, Item)
- Editoren (Document, View, Tool)
- Betriebssysteme (File, Process, Thread)

## **Funktional wählen bei:**
- **Datenverarbeitung** (ETL, Analytics)
- **Compiler** (Parser, Transformer)
- **Mathematische Berechnungen**
- **Parallelisierung** (Map-Reduce)
- **Wenn neue Operationen häufiger als neue Datentypen**

### **Beispiele:**
- Bildverarbeitung (Filter, Transformationen)
- Finanzberechnungen (Portfolioanalyse)
- Wissenschaftliche Simulationen
- Web-APIs (Request → Response)

## **Prozedural wählen bei:**
- **Einfache Skripte** (Automation)
- **Algorithmen** (Sortierung, Suche)
- **Systemnahe Programmierung**
- **Prototyping** (Schnelle Lösungen)

### **Beispiele:**
- Build-Skripte
- Datenbank-Migrationen
- Netzwerk-Tools
- Mathematische Algorithmen

---

# 🧠 **UNVERÄNDERLICHKEIT (IMMUTABILITY)** ⭐⭐

## **Funktionales Prinzip**
```python
# Funktional: Original bleibt unverändert
def add_shape(scene: List[Shape], new_shape: Shape) -> List[Shape]:
    return scene + [new_shape]  # Neue Liste

# Vs. Imperativ: Original wird verändert
def add_shape_imperative(scene: List[Shape], new_shape: Shape) -> None:
    scene.append(new_shape)  # Verändert Original!
```

## **Vorteile von Immutability:**
- **Thread-Sicherheit**: Keine Race Conditions
- **Einfaches Debugging**: Zustand ändert sich nicht unerwartet
- **Undo/Redo**: Alte Zustände bleiben erhalten
- **Caching**: Unveränderliche Objekte sind cachebar

## **Nachteile von Immutability:**
- **Speicherverbrauch**: Viele Kopien
- **Performance**: Kopieren statt Ändern
- **Ungewohnt**: Andere Denkweise erforderlich

---

# 🎯 **KLAUSUR-TYPISCHE FRAGEN**

## **Theoretische Fragen** ⭐⭐⭐

### **1. Erklären Sie das Expression Problem**
**Musterlösung:**
- Problem: Sowohl neue Datentypen als auch neue Operationen hinzufügen
- OOP: Einfach neue Typen, schwer neue Operationen
- Funktional: Einfach neue Operationen, schwer neue Typen
- Kein Paradigma löst es vollständig

### **2. Wann würden Sie OOP vs. Funktional wählen?**
**Musterlösung:**
- OOP: GUI, Frameworks, wenn neue Datentypen häufiger
- Funktional: Datenverarbeitung, Parallelisierung, wenn neue Operationen häufiger
- Hybrid: Functional Core, Imperative Shell

### **3. Vor- und Nachteile von Immutability**
**Musterlösung:**
- Vorteile: Thread-sicher, einfaches Debugging, Undo/Redo
- Nachteile: Speicherverbrauch, Performance, Lernkurve

## **Praktische Aufgaben** ⭐⭐⭐

### **1. Zeigen Sie Expression Problem am Beispiel**
```python
# Gegeben: Shapes mit draw() und transform()
# Aufgabe: Zeigen Sie, wie schwer es ist, rotate() hinzuzufügen (OOP)
# Aufgabe: Zeigen Sie, wie schwer es ist, Pentagon hinzuzufügen (Funktional)
```

### **2. Implementieren Sie Visitor Pattern**
```python
# Aufgabe: SVG-Export für Shapes mittels Visitor Pattern
class ShapeVisitor(ABC):
    # Ihre Implementierung
    pass
```

### **3. Funktionale Transformation**
```python
# Aufgabe: Funktionale Pipeline für Dreiecks-Transformation
def transform_triangles(triangles):
    # subdivide → deform → export
    pass
```

---

# 🔗 **NAVIGATION**

- [← Zurück zu: Grundlagen](1.%20Grundlagen.md)
- [Zur Übersicht](0.%20Index.md)
- [Weiter zu: GUI-Programmierung →](3.%20GUIs.md)
- [Sprung zu: OOP →](5.%20OOP.md)
- [Sprung zu: Funktional →](eis_funktional.md)

---

# 📝 **ZUSAMMENFASSUNG**

## **Wichtigste Punkte für die Klausur:**
1. **Expression Problem**: Neue Typen vs. neue Operationen
2. **OOP**: Einfach neue Typen, schwer neue Operationen
3. **Funktional**: Einfach neue Operationen, schwer neue Typen
4. **Kein Paradigma** löst alles perfekt
5. **Hybrid-Ansätze** kombinieren Vorteile

## **Typische Klausurfragen:**
- Expression Problem erklären
- Trade-offs zwischen Paradigmen
- Wann welches Paradigma verwenden?
- Visitor Pattern implementieren
- Immutability Vor-/Nachteile