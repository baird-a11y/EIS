# ğŸ­ **2. PROGRAMMIERPARADIGMEN**

[â† ZurÃ¼ck zu: Grundlagen](1.%20Grundlagen.md) | [Zur Ãœbersicht](0.%20Index.md) | [Weiter zu: GUI â†’](3.%20GUIs.md)

---

# ğŸ¯ **LERNZIELE**
- Expression Problem verstehen und erklÃ¤ren
- Paradigmen-Trade-offs kennen
- Wann welches Paradigma verwenden
- Vor- und Nachteile aller AnsÃ¤tze

---

# ğŸ¯ **DAS EXPRESSION PROBLEM** â­â­â­ **(SEHR KLAUSURRELEVANT)**

## **Problem-Definition**
**Das zentrale Dilemma der Softwareentwicklung:**
> Wie kann man sowohl neue Datentypen als auch neue Operationen einfach hinzufÃ¼gen, ohne bestehenden Code zu Ã¤ndern?

## **Visualisierung des Problems**

```
           â”‚  draw()  â”‚ transform() â”‚ colorize() â”‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
Triangle   â”‚   âœ“     â”‚      âœ“      â”‚     âœ“      â”‚
Circle     â”‚   âœ“     â”‚      âœ“      â”‚     âœ“      â”‚
Rectangle  â”‚   âœ“     â”‚      âœ“      â”‚     âœ“      â”‚
Group      â”‚   âœ“     â”‚      âœ“      â”‚     âœ“      â”‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
```

**Herausforderungen:**
- **Neue Zeile hinzufÃ¼gen** (neuer Datentyp): `Pentagon`
- **Neue Spalte hinzufÃ¼gen** (neue Operation): `rotate()`

---

# ğŸ—ï¸ **PARADIGMEN-VERGLEICH**

## **1. Objektorientierter Ansatz** â­â­â­

### **StÃ¤rken: Einfach neue Datentypen hinzufÃ¼gen**
```python
# Bestehender Code:
class Shape(ABC):
    @abstractmethod
    def draw(self): pass
    @abstractmethod
    def transform(self): pass
    @abstractmethod
    def colorize(self): pass

class Rectangle(Shape):
    def draw(self): print("Drawing rectangle")
    def transform(self): print("Transforming rectangle")
    def colorize(self): print("Coloring rectangle")

# NEU: Einfach neue Klasse hinzufÃ¼gen
class Pentagon(Shape):  # âœ… EINFACH
    def draw(self): print("Drawing pentagon")
    def transform(self): print("Transforming pentagon")
    def colorize(self): print("Coloring pentagon")
```

### **SchwÃ¤chen: Schwer neue Operationen hinzufÃ¼gen**
```python
# Neue Operation hinzufÃ¼gen: rotate()
class Shape(ABC):
    @abstractmethod
    def draw(self): pass
    @abstractmethod
    def transform(self): pass
    @abstractmethod
    def colorize(self): pass
    @abstractmethod
    def rotate(self): pass  # âŒ ALLE Klassen mÃ¼ssen erweitert werden!

# JEDE bestehende Klasse muss geÃ¤ndert werden:
class Rectangle(Shape):
    def draw(self): print("Drawing rectangle")
    def transform(self): print("Transforming rectangle")
    def colorize(self): print("Coloring rectangle")
    def rotate(self): print("Rotating rectangle")  # âŒ AUFWÃ„NDIG

class Circle(Shape):
    def draw(self): print("Drawing circle")
    def transform(self): print("Transforming circle")
    def colorize(self): print("Coloring circle")
    def rotate(self): print("Rotating circle")  # âŒ AUFWÃ„NDIG
```

## **2. Funktionaler Ansatz** â­â­â­

### **StÃ¤rken: Einfach neue Operationen hinzufÃ¼gen**
```python
# Bestehende Datentypen
shapes = [
    {"type": "rectangle", "x": 0, "y": 0, "width": 10, "height": 5},
    {"type": "circle", "x": 5, "y": 5, "radius": 3},
    {"type": "triangle", "x": 2, "y": 2, "points": [(0,0), (5,0), (2,4)]}
]

# Bestehende Operationen
def draw(shape):
    if shape["type"] == "rectangle":
        print(f"Drawing rectangle at ({shape['x']}, {shape['y']})")
    elif shape["type"] == "circle":
        print(f"Drawing circle at ({shape['x']}, {shape['y']})")
    elif shape["type"] == "triangle":
        print(f"Drawing triangle at ({shape['x']}, {shape['y']})")

def transform(shape):
    if shape["type"] == "rectangle":
        print("Transforming rectangle")
    elif shape["type"] == "circle":
        print("Transforming circle")
    elif shape["type"] == "triangle":
        print("Transforming triangle")

# NEU: Einfach neue Operation hinzufÃ¼gen
def rotate(shape):  # âœ… EINFACH
    if shape["type"] == "rectangle":
        print("Rotating rectangle")
    elif shape["type"] == "circle":
        print("Rotating circle")
    elif shape["type"] == "triangle":
        print("Rotating triangle")
```

### **SchwÃ¤chen: Schwer neue Datentypen hinzufÃ¼gen**
```python
# Neuer Datentyp: Pentagon
pentagon = {"type": "pentagon", "x": 0, "y": 0, "sides": 5}

# ALLE Funktionen mÃ¼ssen erweitert werden:
def draw(shape):
    if shape["type"] == "rectangle":
        print("Drawing rectangle")
    elif shape["type"] == "circle":
        print("Drawing circle")
    elif shape["type"] == "triangle":
        print("Drawing triangle")
    elif shape["type"] == "pentagon":  # âŒ ALLE Funktionen Ã¤ndern!
        print("Drawing pentagon")

def transform(shape):
    if shape["type"] == "rectangle":
        print("Transforming rectangle")
    elif shape["type"] == "circle":
        print("Transforming circle")
    elif shape["type"] == "triangle":
        print("Transforming triangle")
    elif shape["type"] == "pentagon":  # âŒ ALLE Funktionen Ã¤ndern!
        print("Transforming pentagon")
```

---

# ğŸ“Š **TRADE-OFF TABELLE** â­â­â­ **(KLAUSURRELEVANT)**

| Aspekt | Objektorientiert | Funktional | Prozedural |
|--------|------------------|------------|------------|
| **Neue Datentypen** | âœ… Einfach | âŒ Schwer | âŒ Schwer |
| **Neue Operationen** | âŒ Schwer | âœ… Einfach | âœ… Einfach |
| **Performance** | âš ï¸ Overhead | âœ… Optimierbar | âœ… Direkt |
| **Parallelisierung** | âŒ Shared State | âœ… Immutable | âŒ Globals |
| **Testbarkeit** | âš ï¸ Mocking | âœ… Pure Functions | âš ï¸ Seiteneffekte |
| **GUI-Programmierung** | âœ… NatÃ¼rlich | âŒ Kompliziert | âš ï¸ Mittel |
| **Lernkurve** | âš ï¸ Mittel | âŒ Steil | âœ… Einfach |
| **Code-Wiederverwendung** | âœ… Vererbung | âœ… Komposition | âŒ Copy-Paste |

---

# ğŸ”„ **PRAKTISCHE ANWENDUNG: VEKTORGRAFIK-EDITOR**

## **Beispiel: Neue Shape hinzufÃ¼gen**

### **OOP-Ansatz (Einfach):**
```python
class Star(VectorShape):  # âœ… Nur neue Klasse
    def __init__(self, x, y, outer_radius, inner_radius, points):
        super().__init__(x, y, outer_radius*2, outer_radius*2)
        self.outer_radius = outer_radius
        self.inner_radius = inner_radius
        self.points = points
    
    def draw(self, painter, viewport, pixel_size):
        # Stern-spezifische Zeichnung
        pass
    
    def is_hit(self, world_x, world_y):
        # Stern-spezifischer Hit-Test
        pass
```

### **Funktionaler Ansatz (Schwer):**
```python
# ALLE Funktionen mÃ¼ssen erweitert werden:
def draw_shape(shape):
    if shape["type"] == "rectangle":
        draw_rectangle(shape)
    elif shape["type"] == "circle":
        draw_circle(shape)
    elif shape["type"] == "star":  # âŒ Hier hinzufÃ¼gen
        draw_star(shape)

def hit_test(shape, x, y):
    if shape["type"] == "rectangle":
        return hit_test_rectangle(shape, x, y)
    elif shape["type"] == "circle":
        return hit_test_circle(shape, x, y)
    elif shape["type"] == "star":  # âŒ Hier hinzufÃ¼gen
        return hit_test_star(shape, x, y)

def get_bounding_box(shape):
    if shape["type"] == "rectangle":
        return get_rectangle_bounds(shape)
    elif shape["type"] == "circle":
        return get_circle_bounds(shape)
    elif shape["type"] == "star":  # âŒ Hier hinzufÃ¼gen
        return get_star_bounds(shape)

# ... und so weiter fÃ¼r ALLE Funktionen
```

## **Beispiel: Neue Operation hinzufÃ¼gen**

### **Funktionaler Ansatz (Einfach):**
```python
def export_svg(shapes):  # âœ… Nur neue Funktion
    svg_output = '<svg>'
    for shape in shapes:
        if shape["type"] == "rectangle":
            svg_output += f'<rect x="{shape["x"]}" y="{shape["y"]}" width="{shape["width"]}" height="{shape["height"]}" />'
        elif shape["type"] == "circle":
            svg_output += f'<circle cx="{shape["x"]}" cy="{shape["y"]}" r="{shape["radius"]}" />'
        elif shape["type"] == "star":
            svg_output += f'<polygon points="{calculate_star_points(shape)}" />'
    svg_output += '</svg>'
    return svg_output
```

### **OOP-Ansatz (Schwer):**
```python
# ALLE Klassen mÃ¼ssen erweitert werden:
class VectorShape(ABC):
    @abstractmethod
    def draw(self, painter, viewport, pixel_size): pass
    @abstractmethod
    def is_hit(self, world_x, world_y): pass
    @abstractmethod
    def export_svg(self): pass  # âŒ Neue abstrakte Methode

class Rectangle(VectorShape):
    def draw(self, painter, viewport, pixel_size): pass
    def is_hit(self, world_x, world_y): pass
    def export_svg(self):  # âŒ Muss implementiert werden
        return f'<rect x="{self.x}" y="{self.y}" width="{self.width}" height="{self.height}" />'

class Circle(VectorShape):
    def draw(self, painter, viewport, pixel_size): pass
    def is_hit(self, world_x, world_y): pass
    def export_svg(self):  # âŒ Muss implementiert werden
        return f'<circle cx="{self.x}" cy="{self.y}" r="{self.radius}" />'

class Star(VectorShape):
    def draw(self, painter, viewport, pixel_size): pass
    def is_hit(self, world_x, world_y): pass
    def export_svg(self):  # âŒ Muss implementiert werden
        return f'<polygon points="{self.calculate_star_points()}" />'
```

---

# ğŸ”§ **LÃ–SUNGSANSÃ„TZE FÃœR DAS EXPRESSION PROBLEM**

## **1. Visitor Pattern** â­â­

### **Prinzip: Wechsel zu "funktionaler Situation"**
```python
class ShapeVisitor(ABC):
    @abstractmethod
    def visit_rectangle(self, rect): pass
    @abstractmethod
    def visit_circle(self, circle): pass
    @abstractmethod
    def visit_star(self, star): pass

class SVGExportVisitor(ShapeVisitor):  # âœ… Neue Operation als Visitor
    def visit_rectangle(self, rect):
        return f'<rect x="{rect.x}" y="{rect.y}" width="{rect.width}" height="{rect.height}" />'
    
    def visit_circle(self, circle):
        return f'<circle cx="{circle.x}" cy="{circle.y}" r="{circle.radius}" />'
    
    def visit_star(self, star):
        return f'<polygon points="{star.calculate_points()}" />'

class VectorShape(ABC):
    @abstractmethod
    def accept(self, visitor): pass

class Rectangle(VectorShape):
    def accept(self, visitor):
        return visitor.visit_rectangle(self)
```

### **Nachteile des Visitor Patterns:**
- Komplizierter als direkte AnsÃ¤tze
- Trotzdem mÃ¼ssen alle Shapes erweitert werden fÃ¼r neue Visitor-Methoden
- Schwer zu verstehen und zu debuggen

## **2. Hybrid-Ansatz** â­â­

### **Functional Core, Imperative Shell**
```python
# Funktional: Datenstrukturen und Transformationen
def subdivide_triangles(triangles: List[Triangle]) -> List[Triangle]:
    result = []
    for triangle in triangles:
        result.extend(subdivide_triangle(triangle))
    return result

def sine_wave_deform(triangles: List[Triangle]) -> List[Triangle]:
    return [deform_triangle(t) for t in triangles]

# OOP: GUI und Interaktion
class VectorGraphicsArea(QWidget):
    def __init__(self):
        self.shapes = []
        
    def export_svg(self):
        # Geometrie extrahieren (OOP â†’ Funktional)
        triangles = []
        for shape in self.shapes:
            triangles.extend(shape.describe_shape())
        
        # Funktionale Transformationen
        subdivided = subdivide_triangles(triangles)
        deformed = sine_wave_deform(subdivided)
        
        # SVG-Export (Funktional)
        return export_to_svg(deformed)
```

---

# ğŸ¯ **WANN WELCHES PARADIGMA VERWENDEN?** â­â­â­

## **Objektorientiert wÃ¤hlen bei:**
- **GUI-Anwendungen** (Widgets, Events)
- **Frameworks** (Plugin-Systeme)
- **Simulationen** (Objekte mit Zustand)
- **Datenbank-Mapping** (ORM)
- **Wenn neue Datentypen hÃ¤ufiger als neue Operationen**

### **Beispiele:**
- Spiele (Player, Enemy, Item)
- Editoren (Document, View, Tool)
- Betriebssysteme (File, Process, Thread)

## **Funktional wÃ¤hlen bei:**
- **Datenverarbeitung** (ETL, Analytics)
- **Compiler** (Parser, Transformer)
- **Mathematische Berechnungen**
- **Parallelisierung** (Map-Reduce)
- **Wenn neue Operationen hÃ¤ufiger als neue Datentypen**

### **Beispiele:**
- Bildverarbeitung (Filter, Transformationen)
- Finanzberechnungen (Portfolioanalyse)
- Wissenschaftliche Simulationen
- Web-APIs (Request â†’ Response)

## **Prozedural wÃ¤hlen bei:**
- **Einfache Skripte** (Automation)
- **Algorithmen** (Sortierung, Suche)
- **Systemnahe Programmierung**
- **Prototyping** (Schnelle LÃ¶sungen)

### **Beispiele:**
- Build-Skripte
- Datenbank-Migrationen
- Netzwerk-Tools
- Mathematische Algorithmen

---

# ğŸ§  **UNVERÃ„NDERLICHKEIT (IMMUTABILITY)** â­â­

## **Funktionales Prinzip**
```python
# Funktional: Original bleibt unverÃ¤ndert
def add_shape(scene: List[Shape], new_shape: Shape) -> List[Shape]:
    return scene + [new_shape]  # Neue Liste

# Vs. Imperativ: Original wird verÃ¤ndert
def add_shape_imperative(scene: List[Shape], new_shape: Shape) -> None:
    scene.append(new_shape)  # VerÃ¤ndert Original!
```

## **Vorteile von Immutability:**
- **Thread-Sicherheit**: Keine Race Conditions
- **Einfaches Debugging**: Zustand Ã¤ndert sich nicht unerwartet
- **Undo/Redo**: Alte ZustÃ¤nde bleiben erhalten
- **Caching**: UnverÃ¤nderliche Objekte sind cachebar

## **Nachteile von Immutability:**
- **Speicherverbrauch**: Viele Kopien
- **Performance**: Kopieren statt Ã„ndern
- **Ungewohnt**: Andere Denkweise erforderlich

---

# ğŸ¯ **KLAUSUR-TYPISCHE FRAGEN**

## **Theoretische Fragen** â­â­â­

### **1. ErklÃ¤ren Sie das Expression Problem**
**MusterlÃ¶sung:**
- Problem: Sowohl neue Datentypen als auch neue Operationen hinzufÃ¼gen
- OOP: Einfach neue Typen, schwer neue Operationen
- Funktional: Einfach neue Operationen, schwer neue Typen
- Kein Paradigma lÃ¶st es vollstÃ¤ndig

### **2. Wann wÃ¼rden Sie OOP vs. Funktional wÃ¤hlen?**
**MusterlÃ¶sung:**
- OOP: GUI, Frameworks, wenn neue Datentypen hÃ¤ufiger
- Funktional: Datenverarbeitung, Parallelisierung, wenn neue Operationen hÃ¤ufiger
- Hybrid: Functional Core, Imperative Shell

### **3. Vor- und Nachteile von Immutability**
**MusterlÃ¶sung:**
- Vorteile: Thread-sicher, einfaches Debugging, Undo/Redo
- Nachteile: Speicherverbrauch, Performance, Lernkurve

## **Praktische Aufgaben** â­â­â­

### **1. Zeigen Sie Expression Problem am Beispiel**
```python
# Gegeben: Shapes mit draw() und transform()
# Aufgabe: Zeigen Sie, wie schwer es ist, rotate() hinzuzufÃ¼gen (OOP)
# Aufgabe: Zeigen Sie, wie schwer es ist, Pentagon hinzuzufÃ¼gen (Funktional)
```

### **2. Implementieren Sie Visitor Pattern**
```python
# Aufgabe: SVG-Export fÃ¼r Shapes mittels Visitor Pattern
class ShapeVisitor(ABC):
    # Ihre Implementierung
    pass
```

### **3. Funktionale Transformation**
```python
# Aufgabe: Funktionale Pipeline fÃ¼r Dreiecks-Transformation
def transform_triangles(triangles):
    # subdivide â†’ deform â†’ export
    pass
```

---

# ğŸ”— **NAVIGATION**

- [â† ZurÃ¼ck zu: Grundlagen](1.%20Grundlagen.md)
- [Zur Ãœbersicht](0.%20Index.md)
- [Weiter zu: GUI-Programmierung â†’](3.%20GUIs.md)
- [Sprung zu: OOP â†’](5.%20OOP.md)
- [Sprung zu: Funktional â†’](eis_funktional.md)

---

# ğŸ“ **ZUSAMMENFASSUNG**

## **Wichtigste Punkte fÃ¼r die Klausur:**
1. **Expression Problem**: Neue Typen vs. neue Operationen
2. **OOP**: Einfach neue Typen, schwer neue Operationen
3. **Funktional**: Einfach neue Operationen, schwer neue Typen
4. **Kein Paradigma** lÃ¶st alles perfekt
5. **Hybrid-AnsÃ¤tze** kombinieren Vorteile

## **Typische Klausurfragen:**
- Expression Problem erklÃ¤ren
- Trade-offs zwischen Paradigmen
- Wann welches Paradigma verwenden?
- Visitor Pattern implementieren
- Immutability Vor-/Nachteile