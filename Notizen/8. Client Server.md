# üåê **8. CLIENT-SERVER ARCHITEKTUR**

[‚Üê Zur√ºck zu: Performance](7.%20Performance.md) | [Zur √úbersicht](eis_main_index.md) | [Weiter zu: √úbungen ‚Üí](eis_uebungen.md)

---

# üéØ **LERNZIELE**
- Socket-Programmierung beherrschen
- HTTP-Protokoll verstehen
- Threading f√ºr Multi-Client Support
- Netzwerk-Sicherheit beachten
- Client-Server Patterns anwenden

---

# üèóÔ∏è **CLIENT-SERVER ARCHITEKTUR** ‚≠ê‚≠ê‚≠ê **(SEHR KLAUSURRELEVANT)**

## **Grundprinzip** ‚≠ê‚≠ê‚≠ê

```
Client-Prozess                    Server-Prozess
‚îú‚îÄ‚îÄ socket()                      ‚îú‚îÄ‚îÄ socket()
‚îú‚îÄ‚îÄ connect(server_ip, port)      ‚îú‚îÄ‚îÄ bind(ip, port)
‚îú‚îÄ‚îÄ send(request)                 ‚îú‚îÄ‚îÄ listen()
‚îú‚îÄ‚îÄ recv(response)                ‚îú‚îÄ‚îÄ accept() ‚Üí neue Verbindung
‚îî‚îÄ‚îÄ close()                       ‚îú‚îÄ‚îÄ recv(request)
                                  ‚îú‚îÄ‚îÄ send(response)
                                  ‚îî‚îÄ‚îÄ close()
```

## **Standard-Architektur** ‚≠ê‚≠ê‚≠ê

### **Server-Seite:**
```python
import socket
import threading

def handle_client(client_socket, client_address):
    """Handler f√ºr einzelne Client-Verbindung"""
    print(f"Client {client_address} connected")
    
    try:
        while True:
            # Request empfangen
            data = client_socket.recv(4096)
            if not data:
                break
                
            request = data.decode('utf-8').strip()
            print(f"Request: {request}")
            
            # Response generieren
            response = process_request(request)
            
            # Response senden
            client_socket.sendall(response.encode('utf-8'))
            
    except Exception as e:
        print(f"Error handling client {client_address}: {e}")
    finally:
        client_socket.close()
        print(f"Client {client_address} disconnected")

def start_server(port=8080):
    """Multi-threaded Server"""
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
    try:
        server_socket.bind(('127.0.0.1', port))
        server_socket.listen(5)  # Max 5 wartende Verbindungen
        print(f"Server listening on port {port}")
        
        while True:
            # Auf Client-Verbindung warten
            client_socket, client_address = server_socket.accept()
            
            # Neuer Thread f√ºr jeden Client
            client_thread = threading.Thread(
                target=handle_client,
                args=(client_socket, client_address)
            )
            client_thread.daemon = True
            client_thread.start()
            
    except KeyboardInterrupt:
        print("Server shutting down...")
    finally:
        server_socket.close()
```

### **Client-Seite:**
```python
import socket

def simple_client(server_host='127.0.0.1', server_port=8080):
    """Einfacher Client"""
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    try:
        # Mit Server verbinden
        client_socket.connect((server_host, server_port))
        print(f"Connected to {server_host}:{server_port}")
        
        while True:
            # Benutzer-Eingabe
            message = input("Enter message (or 'quit' to exit): ")
            if message.lower() == 'quit':
                break
                
            # Nachricht senden
            client_socket.sendall(message.encode('utf-8'))
            
            # Antwort empfangen
            response = client_socket.recv(4096)
            print(f"Server response: {response.decode('utf-8')}")
            
    except Exception as e:
        print(f"Client error: {e}")
    finally:
        client_socket.close()
```

---

# üîå **SOCKET-API** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

## **Server-Socket Lifecycle** ‚≠ê‚≠ê‚≠ê

```python
# 1. Socket erstellen
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 2. Adresse binden
server_socket.bind(('127.0.0.1', 8080))

# 3. Auf Verbindungen lauschen
server_socket.listen(5)

# 4. Verbindung akzeptieren
client_socket, client_address = server_socket.accept()

# 5. Daten empfangen/senden
data = client_socket.recv(4096)
client_socket.sendall(response.encode('utf-8'))

# 6. Verbindung schlie√üen
client_socket.close()
server_socket.close()
```

## **Client-Socket Lifecycle** ‚≠ê‚≠ê‚≠ê

```python
# 1. Socket erstellen
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 2. Mit Server verbinden
client_socket.connect(('127.0.0.1', 8080))

# 3. Daten senden/empfangen
client_socket.sendall(request.encode('utf-8'))
response = client_socket.recv(4096)

# 4. Verbindung schlie√üen
client_socket.close()
```

## **Wichtige Socket-Optionen** ‚≠ê‚≠ê

```python
# Port-Wiederverwendung (wichtig f√ºr Server-Restart)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

# Timeout setzen
client_socket.settimeout(5.0)  # 5 Sekunden Timeout

# Non-blocking Socket
server_socket.setblocking(False)

# Buffer-Gr√∂√üen
client_socket.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 8192)
client_socket.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 8192)
```

---

# üåê **HTTP-PROTOKOLL** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

## **HTTP-Request Format** ‚≠ê‚≠ê‚≠ê

```
GET /index.html HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1

[Optional Body f√ºr POST]
```

## **HTTP-Response Format** ‚≠ê‚≠ê‚≠ê

```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 1234
Server: EiS-Server/1.0
Date: Wed, 16 Jul 2025 10:00:00 GMT
Connection: close

<!DOCTYPE html>
<html>
<head><title>Hello World</title></head>
<body><h1>Hello from EiS Server!</h1></body>
</html>
```

## **HTTP-Status Codes** ‚≠ê‚≠ê

```python
HTTP_STATUS_CODES = {
    200: "OK",
    201: "Created",
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    500: "Internal Server Error",
    501: "Not Implemented",
    503: "Service Unavailable"
}
```

## **HTTP-Server Implementation** ‚≠ê‚≠ê‚≠ê

```python
import os
import urllib.parse
from datetime import datetime

class HTTPServer:
    def __init__(self, document_root="www"):
        self.document_root = document_root
        
    def parse_request(self, request_data):
        """Parst HTTP-Request"""
        lines = request_data.strip().split('\n')
        if not lines:
            return None, None, None
            
        # Request-Line parsen
        request_line = lines[0]
        parts = request_line.split(' ')
        if len(parts) != 3:
            return None, None, None
            
        method, path, version = parts
        
        # Headers parsen
        headers = {}
        for line in lines[1:]:
            if ':' in line:
                key, value = line.split(':', 1)
                headers[key.strip()] = value.strip()
                
        return method, path, headers
    
    def generate_response(self, method, path, headers):
        """Generiert HTTP-Response"""
        if method != 'GET':
            return self.error_response(405, "Method Not Allowed")
            
        # Sicherheit: Path normalisieren
        path = urllib.parse.unquote(path)
        if path.startswith('/'):
            path = path[1:]
        if not path:
            path = 'index.html'
            
        # Pfad-Injection verhindern
        if '..' in path or path.startswith('/'):
            return self.error_response(403, "Forbidden")
            
        file_path = os.path.join(self.document_root, path)
        
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read()
                
            # Content-Type bestimmen
            content_type = self.get_content_type(file_path)
            
            # Success Response
            response = f"HTTP/1.1 200 OK\r\n"
            response += f"Content-Type: {content_type}\r\n"
            response += f"Content-Length: {len(content.encode('utf-8'))}\r\n"
            response += f"Server: EiS-Server/1.0\r\n"
            response += f"Date: {datetime.now().strftime('%a, %d %b %Y %H:%M:%S GMT')}\r\n"
            response += f"Connection: close\r\n"
            response += f"\r\n"
            response += content
            
            return response
            
        except FileNotFoundError:
            return self.error_response(404, "Not Found")
        except Exception as e:
            return self.error_response(500, "Internal Server Error")
    
    def error_response(self, status_code, status_text):
        """Generiert Error-Response"""
        content = f"<html><body><h1>{status_code} {status_text}</h1></body></html>"
        
        response = f"HTTP/1.1 {status_code} {status_text}\r\n"
        response += f"Content-Type: text/html\r\n"
        response += f"Content-Length: {len(content)}\r\n"
        response += f"Server: EiS-Server/1.0\r\n"
        response += f"Connection: close\r\n"
        response += f"\r\n"
        response += content
        
        return response
    
    def get_content_type(self, file_path):
        """Bestimmt Content-Type basierend auf Dateiendung"""
        if file_path.endswith('.html'):
            return 'text/html; charset=utf-8'
        elif file_path.endswith('.css'):
            return 'text/css'
        elif file_path.endswith('.js'):
            return 'application/javascript'
        elif file_path.endswith('.json'):
            return 'application/json'
        elif file_path.endswith('.png'):
            return 'image/png'
        elif file_path.endswith('.jpg') or file_path.endswith('.jpeg'):
            return 'image/jpeg'
        else:
            return 'text/plain'
    
    def handle_request(self, request_data):
        """Haupthandler f√ºr HTTP-Request"""
        method, path, headers = self.parse_request(request_data)
        
        if method is None:
            return self.error_response(400, "Bad Request")
            
        return self.generate_response(method, path, headers)
```

---

# üßµ **THREADING F√úR MULTI-CLIENT SUPPORT** ‚≠ê‚≠ê‚≠ê

## **Thread-per-Client Pattern** ‚≠ê‚≠ê‚≠ê

```python
import threading
import time

class ThreadedServer:
    def __init__(self, port=8080):
        self.port = port
        self.running = False
        self.clients = []
        self.lock = threading.Lock()
        
    def start(self):
        """Startet den Server"""
        self.running = True
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        try:
            self.server_socket.bind(('127.0.0.1', self.port))
            self.server_socket.listen(10)
            print(f"Server started on port {self.port}")
            
            while self.running:
                try:
                    client_socket, client_address = self.server_socket.accept()
                    
                    # Client-Thread starten
                    client_thread = threading.Thread(
                        target=self.handle_client,
                        args=(client_socket, client_address)
                    )
                    client_thread.daemon = True
                    client_thread.start()
                    
                    # Client-Liste aktualisieren (Thread-safe)
                    with self.lock:
                        self.clients.append({
                            'socket': client_socket,
                            'address': client_address,
                            'thread': client_thread,
                            'connected_at': time.time()
                        })
                        
                except Exception as e:
                    if self.running:
                        print(f"Error accepting connection: {e}")
                        
        finally:
            self.server_socket.close()
    
    def handle_client(self, client_socket, client_address):
        """Handler f√ºr einzelnen Client"""
        try:
            while self.running:
                # Timeout f√ºr recv setzen
                client_socket.settimeout(1.0)
                
                try:
                    data = client_socket.recv(4096)
                    if not data:
                        break
                        
                    request = data.decode('utf-8')
                    print(f"[{client_address}] Request: {request[:50]}...")
                    
                    # Request verarbeiten
                    response = self.process_request(request)
                    
                    # Response senden
                    client_socket.sendall(response.encode('utf-8'))
                    
                except socket.timeout:
                    continue  # Timeout ist normal
                except Exception as e:
                    print(f"[{client_address}] Error: {e}")
                    break
                    
        finally:
            client_socket.close()
            
            # Client aus Liste entfernen
            with self.lock:
                self.clients = [c for c in self.clients if c['address'] != client_address]
            
            print(f"[{client_address}] Disconnected")
    
    def process_request(self, request):
        """Verarbeitet HTTP-Request"""
        http_server = HTTPServer()
        return http_server.handle_request(request)
    
    def stop(self):
        """Stoppt den Server"""
        self.running = False
        
        # Alle Client-Verbindungen schlie√üen
        with self.lock:
            for client in self.clients:
                try:
                    client['socket'].close()
                except:
                    pass
        
        if hasattr(self, 'server_socket'):
            self.server_socket.close()
    
    def get_status(self):
        """Gibt Server-Status zur√ºck"""
        with self.lock:
            return {
                'running': self.running,
                'port': self.port,
                'clients': len(self.clients),
                'client_list': [
                    {
                        'address': c['address'],
                        'connected_at': c['connected_at'],
                        'uptime': time.time() - c['connected_at']
                    }
                    for c in self.clients
                ]
            }
```

## **Threading-Probleme und L√∂sungen** ‚≠ê‚≠ê

### **1. Race Conditions**
```python
# ‚ùå PROBLEM: Nicht Thread-safe
class BadCounter:
    def __init__(self):
        self.count = 0
    
    def increment(self):
        temp = self.count
        # Andere Threads k√∂nnen hier dazwischenfunken!
        temp += 1
        self.count = temp

# ‚úÖ L√ñSUNG: Thread-safe mit Lock
class GoodCounter:
    def __init__(self):
        self.count = 0
        self.lock = threading.Lock()
    
    def increment(self):
        with self.lock:
            self.count += 1  # Atomare Operation
```

### **2. Deadlocks**
```python
# ‚ùå PROBLEM: Deadlock m√∂glich
lock1 = threading.Lock()
lock2 = threading.Lock()

def thread1():
    with lock1:
        time.sleep(0.1)
        with lock2:
            pass

def thread2():
    with lock2:
        time.sleep(0.1)
        with lock1:  # Deadlock!
            pass

# ‚úÖ L√ñSUNG: Konsistente Lock-Reihenfolge
def thread1_fixed():
    with lock1:
        with lock2:
            pass

def thread2_fixed():
    with lock1:  # Gleiche Reihenfolge!
        with lock2:
            pass
```

---

# üîí **NETZWERK-SICHERHEIT** ‚≠ê‚≠ê‚≠ê **(KLAUSURRELEVANT)**

## **Sicherheitsbedrohungen** ‚≠ê‚≠ê‚≠ê

### **1. Path Traversal (Directory Traversal)**
```python
# ‚ùå ANF√ÑLLIG f√ºr Path Traversal
def serve_file_bad(filename):
    file_path = os.path.join("www", filename)
    # Angreifer: filename = "../../etc/passwd"
    # Resultat: "www/../../etc/passwd" = "/etc/passwd"
    with open(file_path, 'r') as f:
        return f.read()

# ‚úÖ SICHER: Input-Validation
def serve_file_safe(filename):
    # Pfad normalisieren
    filename = os.path.normpath(filename)
    
    # ".." verbieten
    if '..' in filename:
        raise ValueError("Invalid path")
    
    # Absoluten Pfad verbieten
    if os.path.isabs(filename):
        raise ValueError("Absolute paths not allowed")
    
    file_path = os.path.join("www", filename)
    
    # Sicherstellen dass Pfad innerhalb www bleibt
    if not os.path.abspath(file_path).startswith(os.path.abspath("www")):
        raise ValueError("Path outside document root")
    
    with open(file_path, 'r') as f:
        return f.read()
```

### **2. Buffer Overflow**
```python
# ‚ùå ANF√ÑLLIG f√ºr gro√üe Requests
def handle_request_bad(client_socket):
    data = client_socket.recv(1024*1024*100)  # 100MB Buffer!
    # Angreifer kann Server zum Absturz bringen

# ‚úÖ SICHER: Begrenzte Buffer-Gr√∂√üe
def handle_request_safe(client_socket):
    MAX_REQUEST_SIZE = 8192  # 8KB Maximum
    
    data = b''
    while len(data) < MAX_REQUEST_SIZE:
        chunk = client_socket.recv(min(4096, MAX_REQUEST_SIZE - len(data)))
        if not chunk:
            break
        data += chunk
    
    if len(data) >= MAX_REQUEST_SIZE:
        raise ValueError("Request too large")
    
    return data.decode('utf-8')
```

### **3. Localhost-Only Binding**
```python
# ‚ùå UNSICHER: Bindet an alle Interfaces
server_socket.bind(('0.0.0.0', 8080))  # Erreichbar aus dem Internet!

# ‚úÖ SICHER: Nur localhost
server_socket.bind(('127.0.0.1', 8080))  # Nur lokal erreichbar
```

### **4. Input Sanitization**
```python
def sanitize_input(user_input):
    """Bereinigt Benutzer-Eingaben"""
    # HTML-Escaping
    user_input = user_input.replace('<', '&lt;')
    user_input = user_input.replace('>', '&gt;')
    user_input = user_input.replace('"', '&quot;')
    user_input = user_input.replace("'", '&#x27;')
    
    # Maximale L√§nge
    if len(user_input) > 1000:
        raise ValueError("Input too long")
    
    # Nur erlaubte Zeichen
    allowed_chars = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .-_')
    if not all(c in allowed_chars for c in user_input):
        raise ValueError("Invalid characters")
    
    return user_input
```

---

# üéØ **KLAUSUR-TYPISCHE AUFGABEN** ‚≠ê‚≠ê‚≠ê

## **Aufgabe 1: Einfacher Echo-Server** ‚≠ê‚≠ê‚≠ê

```python
def echo_server(port=8080):
    """Implementieren Sie einen Echo-Server der empfangene Nachrichten zur√ºcksendet"""
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
    try:
        server_socket.bind(('127.0.0.1', port))
        server_socket.listen(5)
        print(f"Echo server listening on port {port}")
        
        while True:
            client_socket, client_address = server_socket.accept()
            print(f"Client connected: {client_address}")
            
            try:
                while True:
                    data = client_socket.recv(4096)
                    if not data:
                        break
                    
                    message = data.decode('utf-8')
                    print(f"Received: {message}")
                    
                    # Echo zur√ºcksenden
                    echo_response = f"Echo: {message}"
                    client_socket.sendall(echo_response.encode('utf-8'))
                    
            except Exception as e:
                print(f"Error: {e}")
            finally:
                client_socket.close()
                print(f"Client disconnected: {client_address}")
                
    except KeyboardInterrupt:
        print("Server shutting down...")
    finally:
        server_socket.close()
```

## **Aufgabe 2: HTTP-Request Parser** ‚≠ê‚≠ê‚≠ê

```python
def parse_http_request(request_string):
    """
    Parst HTTP-Request und gibt Method, Path, Headers zur√ºck
    
    Beispiel Input:
    "GET /index.html HTTP/1.1\r\nHost: localhost\r\n\r\n"
    
    Beispiel Output:
    ("GET", "/index.html", {"Host": "localhost"})
    """
    lines = request_string.strip().split('\r\n')
    if not lines:
        return None, None, None
    
    # Request-Line parsen
    request_line = lines[0]
    parts = request_line.split(' ')
    if len(parts) != 3:
        return None, None, None
    
    method, path, version = parts
    
    # Headers parsen
    headers = {}
    for line in lines[1:]:
        if line == '':  # Ende der Headers
            break
        if ':' in line:
            key, value = line.split(':', 1)
            headers[key.strip()] = value.strip()
    
    return method, path, headers

# Test
request = "GET /index.html HTTP/1.1\r\nHost: localhost:8080\r\nUser-Agent: Mozilla/5.0\r\n\r\n"
method, path, headers = parse_http_request(request)
print(f"Method: {method}")
print(f"Path: {path}")
print(f"Headers: {headers}")
```

## **Aufgabe 3: Multi-threaded File Server** ‚≠ê‚≠ê‚≠ê

```python
def threaded_file_server(port=8080, document_root="www"):
    """
    Implementieren Sie einen Multi-threaded File Server
    - Jeder Client bekommt eigenen Thread
    - Dateien aus document_root servieren
    - Sichere Pfad-Behandlung
    """
    
    def handle_client(client_socket, client_address):
        try:
            while True:
                data = client_socket.recv(4096)
                if not data:
                    break
                
                filename = data.decode('utf-8').strip()
                
                # Sicherheitscheck
                if '..' in filename or filename.startswith('/'):
                    response = "ERROR: Invalid path"
                    client_socket.sendall(response.encode('utf-8'))
                    continue
                
                file_path = os.path.join(document_root, filename)
                
                try:
                    with open(file_path, 'r') as file:
                        content = file.read()
                    client_socket.sendall(content.encode('utf-8'))
                except FileNotFoundError:
                    error_message = f"ERROR: File '{filename}' not found"
                    client_socket.sendall(error_message.encode('utf-8'))
                    
        except Exception as e:
            print(f"Client {client_address} error: {e}")
        finally:
            client_socket.close()
    
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
    try:
        server_socket.bind(('127.0.0.1', port))
        server_socket.listen(10)
        print(f"File server listening on port {port}")
        
        while True:
            client_socket, client_address = server_socket.accept()
            
            # Neuer Thread f√ºr jeden Client
            client_thread = threading.Thread(
                target=handle_client,
                args=(client_socket, client_address)
            )
            client_thread.daemon = True
            client_thread.start()
            
    except KeyboardInterrupt:
        print("Server shutting down...")
    finally:
        server_socket.close()
```

## **Aufgabe 4: Exception Handling** ‚≠ê‚≠ê

```python
def robust_client(host='127.0.0.1', port=8080):
    """
    Implementieren Sie einen robusten Client mit vollst√§ndigem Exception Handling
    """
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.settimeout(5.0)  # 5 Sekunden Timeout
    
    try:
        # Verbindung aufbauen
        client_socket.connect((host, port))
        print(f"Connected to {host}:{port}")
        
        while True:
            try:
                message = input("Enter message (or 'quit' to exit): ")
                if message.lower() == 'quit':
                    break
                
                # Nachricht senden
                client_socket.sendall(message.encode('utf-8'))
                
                # Antwort empfangen
                response = client_socket.recv(4096)
                if response:
                    print(f"Server: {response.decode('utf-8')}")
                else:
                    print("Server closed connection")
                    break
                    
            except socket.timeout:
                print("Request timed out")
                continue
            except KeyboardInterrupt:
                print("\nClient interrupted by user")
                break
            except Exception as e:
                print(f"Error during communication: {e}")
                break
                
    except ConnectionRefusedError:
        print(f"Could not connect to {host}:{port} - server not running?")
    except socket.timeout:
        print(f"Connection to {host}:{port} timed out")
    except Exception as e:
        print(f"Unexpected error: {e}")
    finally:
        client_socket.close()
        print("Connection closed")
```

---

# üîó **NAVIGATION**

- [‚Üê Zur√ºck zu: Performance](7.%20Performance.md)
- [Zur √úbersicht](eis_main_index.md)
- [Weiter zu: √úbungen ‚Üí](eis_uebungen.md)
- [Sprung zu: Grundlagen ‚Üí](eis_grundlagen.md)

---

# üìù **ZUSAMMENFASSUNG**

## **Wichtigste Punkte f√ºr die Klausur:**
1. **Socket-API**: `socket()`, `bind()`, `listen()`, `accept()`, `connect()`, `send()`, `recv()`
2. **HTTP-Format**: Request-Line, Headers, Body / Status-Line, Headers, Body
3. **Threading**: Ein Thread pro Client, Thread-Sicherheit beachten
4. **Sicherheit**: Path Traversal, Buffer Overflow, Input Sanitization
5. **Exception Handling**: ConnectionRefusedError, socket.timeout, robuste Clients

## **Typische Klausurfragen:**
- Socket-Server/Client implementieren
- HTTP-Request parsen
- Multi-Threading f√ºr Server
- Sicherheitsprobleme identifizieren
- Exception Handling implementieren

## **Wichtige APIs auswendig:**
```python
# Server
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(('127.0.0.1', port))
server_socket.listen(5)
client_socket, address = server_socket.accept()

# Client
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.connect(('127.0.0.1', port))
client_socket.sendall(data.encode('utf-8'))
response = client_socket.recv(4096)
```